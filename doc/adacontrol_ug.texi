\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename adacontrol_ug.info
@settitle AdaControl User Guide V1.7r9
@c %**end of header
@macro rule{text}
@sp 1
@noindent @b{\text\}
@end macro

@titlepage
@title AdaControl User Guide

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@end titlepage

@ifnottex
@node Top, Introduction, (dir), (dir)
@top AdaControl User Guide
This is the AdaControl User Guide. It describes how to install and use
AdaControl. Please refer to the AdaControl Programmer Manual to learn
how to add new kinds of rules to AdaControl.
@end ifnottex

Last edited: @today{}

@menu
* Introduction::                
* Installation::                
* Program Usage::               
* Rules Usage::                 
* Examples of using AdaControl for common programming rules::  
* Non upward-compatible changes::  
* Syntax of regular expressions::  
@end menu

AdaControl is Copyright @copyright{} 2005 Eurocontrol/Adalog, except
for some specific modules that are @copyright{} 2006
Belgocontrol/Adalog, @copyright{} 2006 CSEE/Adalog, or @copyright{}
2006 SAGEM/Adalog. AdaControl is free software; you can redistribute
it and/or modify it under terms of the GNU General Public License as
published by the Free Software Foundation; either version 2, or (at
your option) any later version. This unit is distributed in the hope
that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.  You
should have received a copy of the GNU General Public License
distributed with this program; see file COPYING.  If not, write to the
Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.

As a special exception, if other files instantiate generics from this
program, or if you link units from this program with other files to
produce an executable, this does not by itself cause the resulting
executable to be covered by the GNU General Public License. This
exception does not however invalidate any other reasons why the
executable file might be covered by the GNU Public License.

This document is Copyright @copyright{} 2005-2006
Eurocontrol/Adalog. This document may be copied, in whole or in part,
in any form or by any means, as is or with alterations, provided that
(1) alterations are clearly marked as alterations and (2) this
copyright notice is included unmodified in any copy.

@iftex
@contents
@end iftex

@node Introduction, Installation, Top, Top
@chapter Introduction
AdaControl is an Ada rules controller. It is used to control that Ada
software meets the requirements of a number of parameterizable
rules. It is not intended to supplement checks made by the compiler,
but rather to search for particular violations of good-practice rules,
or to check that some rules are obeyed project-wide. AdaControl can
also be handy to make statistics about certain usages of language
features, or simply to search for the occurrences of particular
constructs; its scope is therefore not limited to enforcing
programming rules, although it is of course one of its main goals.

The development of AdaControl was initially funded by Eurocontrol
(@uref{http://www.eurocontrol.int}), which needed a tool to help in
verifying the million+ lines of code that does Air Traffic Flow
Management over Europe. Because it was felt that such a tool would
benefit the community at-large, and that further improvements made by
the community would benefit Eurocontrol, it was decided to release
AdaControl as free software. Later, Eurocontrol, Belgocontrol,
CSEE-Transport, and SAGEM-DS sponsored the development of more rules.

The requirements for AdaControl were written by Philippe Waroquiers
(Eurocontrol-Brussels), who also conducted extensive testing on the
Eurocontrol software. The software was developped by Arnaud Lecanu and
Jean-Pierre Rosen (Adalog). Some rules were contributed by Richard Toy
(Eurocontrol-Maastricht), Pierre-Louis Escouflaire (Adalog), and Alain
Fontaine (ABF consulting). AdaGide support was contributed by Gautier
de Montmollin.

Commercial support is available for AdaControl, see file
@code{doc/support.txt}. If you plan to use AdaControl for industrial
projects, or if you want it to be customized or extended to match your
own needs, please contact Adalog at
@uref{mailto::info@@adalog.fr,,info@@adalog.fr}.

See file @code{HISTORY} for a description of the various versions of
AdaControl, including enhancements of the current version over the
previous ones. Users of a previous version are warned that the rules
are not 100% upward-compatible: this is necessary to make the rules
more consistent and easier to use. However, the incompatibilities are
straightforward to fix and should affect only a very limited number of
files. @pxref{Non upward-compatible changes} for details.

@node Installation, Program Usage, Introduction, Top
@chapter Installation
Like any ASIS application, AdaControl can be run only if the compiler
available on the system has exactly the same version as the one used
to compile AdaControl itself. The executable distribution of
AdaControl will work only with Gnat version GPL 2007, as distributed
by ACT. If you are using any other version,  please use the source
distribution of AdaControl and compile it as indicated
below. @xref{Building AdaControl from source}.

Another reason for using the source distribution of AdaControl is that
the user may not be interested in all provided rules. It is very easy
to remove some rules from AdaControl to increase its
speed. @xref{Customizing AdaControl}.

@menu
* Building AdaControl from source::  
* Installing AdaControl::       
* Installing support for GPS::  
* Installing support for AdaGide::  
@end menu

@node Building AdaControl from source, Installing AdaControl, Installation, Installation
@section Building AdaControl from source
This section is only for the source distribution of AdaControl. If you
downloaded an executable distribution (and are using Gnat GPL 2007),
you may skip to the next section.

@subsection Prerequisites
The following software must be installed in order to compile
AdaControl from source:
@itemize
@item
A GNAT compiler, any version. Note that the compiler is also required
to use AdaControl (all ASIS application need the compiler).
@item
ASIS for GNAT
@end itemize

Make sure to have the same version of GNAT and ASIS. The version used
for running AdaControl must be the same as the one used to compile
AdaControl itself.

It should be possible to compile AdaControl with other compilers than
GNAT, although we didn't have an opportunity to try it. If you have
another compiler that supports ASIS, note that it may require some
easy changes in the package @code{Implementation_Options} to give
proper parameters to the @code{Associate} procedure of ASIS.  Rules
that need string pattern matchings need the package
@code{Gnat.Regpat}. If you compile AdaControl with another compiler,
you can either port @code{Gnat.Regpat} to your system, or use a
(limited) portable implementation of a simple pattern matching
(package @code{String_Matching_Portable}). Edit the file
@code{string_matching.ads} and change it as indicated in the comments.
No other change should be necessary.

Alternatively, if you are using another compiler, you can try and
compile your program with GNAT just to be able to run
AdaControl. However, compilers often differ in their support of
representation clauses, which can cause your program to be rejected by
GNAT. In that case, we provide a sed script to comment-out all
representation clauses; this can be sufficient to allow you to use
AdaControl. @xref{unrepr.sed}.

@subsection Build with project file
Simply go to the @code{src} directory and type:
@example
gnatmake -Pbuild.gpr
@end example
You're done!
@subsection Build with Makefile
The previous method may fail if Asis is not installed in an usual
place. As an alternative method, it is possible to build AdaControl
with a regular Makefile.

The file @code{Makefile} (in directory @code{src}) should be modified
to match the  commands and paths of the target system. The following
variables are to be set:
@itemize
@item
ASIS_TOP
@item
ASIS_INCLUDE
@item
ASIS_OBJ
@item
ASIS_LIB
@item
RM
@item
EXT
@end itemize

How to set these variables properly is documented in @code{Makefile}.

Then, run the make command:
@example
$ cd src
$ make build
@end example

It is also possible to delete object files and do other actions with
this  ``Makefile'', run the following command to get more information:
@example
$ make help
@end example

NOTE: Building AdaControl needs the ``make'' command provide with GNAT; it
works both with WIN32 shell and UNIX shell.

@subsection Testing AdaControl
Testing AdaControl needs a UNIX shell, so it works only with UNIX
systems.  However, it is possible to run the tests on a WIN32 system
by using an UNIX-like shell for WIN32, such as those provided by
CYGWIN or MSYS. To run the tests, enter the following commands:
@example
$ cd test
$ ./run.sh
@end example

All tests must report PASSED. If they don't, it may be because you are
using an old version of Gnat (and especially 3.15p). AdaControl runs
without any known problem (and it has been checked against the whole
ACATS) only with the latest GnatPro version; earlier versions are
known to have bugs and unimplemented features that will not allow
AdaControl to run correctly in some cases. We strongly recommend to
always use the most recent version of Gnat.

@anchor{Customizing AdaControl}
@subsection Customizing AdaControl
If there are some rules that you are not interested in, it is very easy
to remove them from AdaControl:
@enumerate
@item
In the @code{src} directory, edit the file
@code{framework-plugs.adb}. There is a @code{with} clause for each
rule (children of package @code{Rules}). Comment out the ones you
don't want.
@item
Recompile @code{framework-plugs.adb}. There will be error messages
about unknown procedure calls. Comment out the corresponding lines.
@item
Compile AdaControl normally. That's all!
@end enumerate

It is also possible to add new rules to AdaControl. If your favorite
rules are not currently supported, you have several options:
@enumerate
@item
If you have some funding available, please contact
@uref{mailto::info@@adalog.fr,,info@@adalog.fr}. We'll be happy to
make an offer to customize AdaControl to your needs.
@item
If you @i{don't} have funding, but have some knowledge of ASIS
programming, you can add the rule yourself. We have made every effort
to make this as simple as possible. Please refer to the AdaControl
programmer's manual for details. If you do so, please send your rules
to @uref{mailto::rosen@@adalog.fr,,rosen@@adalog.fr}, and we'll be
happy to integrate them in the general release of AdaControl to make them
available to everybody.
@item
If you have good ideas, but don't feel like implementing them yourself
(nor financing them), please send a note to
@uref{mailto::rosen@@adalog.fr,,rosen@@adalog.fr}. We will eventually
incorporate all good suggestions, but we can't of course commit to any
dead-line in that case.
@end enumerate

@node Installing AdaControl, Installing support for GPS, Building AdaControl from source, Installation
@section Installing AdaControl
All you need to run AdaControl is the executable named  @code{adactl}
under Linux or @code{adactl.exe} under Windows. In addition,
@code{pfni} (or @code{pfni.exe} under Windows) is a convenient
utility, required by the GPS support. @xref{pfni}.

If you built AdaControl from source, these executables are in the
@code{src} directory of the distribution. If you downloaded an
executable distribution, they are in the root directory of the
distribution. Copy the executables to any convenient directory on your
path; a good place, for example, is in the @code{bin} directory of
your Gnat installation.

@node Installing support for GPS, Installing support for AdaGide, Installing AdaControl, Installation
@section Installing support for GPS
To add AdaControl support to GPS, copy all the files from the
@code{GPS} directory into the @code{<GPS_dir>/share/gps/plug-ins}
directory. Copy also the files @code{doc/adacontrol_ug.html} and
@code{doc/adacontrol_pm.html} into the @code{<GPS_dir>/share/doc/gps/html}
to access AdaControl's guides from the "Help" menu of GPS.

This version includes a work-around for a bug in GPS 4.x. If you are
using GPS 3.x, edit the file @code{adactl.py} and change the line that
reads:
@example
GPS4_Bug=True
@end example
to:
@example
GPS4_Bug=False
@end example

@node Installing support for AdaGide,  , Installing support for GPS, Installation
@section Installing support for AdaGide
To add AdaControl support to AdaGide, copy the file
@code{AdaControl.tdf} from the @code{AdaGide} directory into AdaGide's
root directory. Note that AdaControl support requires AdaGide version
7.42 or above.

@node Program Usage, Rules Usage, Installation, Top
@chapter Program Usage
@menu
* Running AdaControl from the command line::  
* Running AdaControl from GPS::  
* Running AdaControl from AdaGide::  
* Rules syntax::                
* Commands::                    
* Command line options and parameters::  
* Return codes::                
* Disabling rules::             
* Helpful utilities::           
* Optimizing  AdaControl::      
* In case of trouble::          
@end menu

@node Running AdaControl from the command line, Running AdaControl from GPS, Program Usage, Program Usage
@section Running AdaControl from the command line
AdaControl is a command-line program, i.e. it's callable directly by a
system shell, and can be integrated in GUIs such as GPS
(@pxref{Running AdaControl from GPS}) or emacs (@pxref{Rule types and
report messages}). It is very simple to use. It takes, as parameters, a
list of units to process and a set of rules to apply.  AdaControl
produces error and/or found messages to the standard output. The type
of message (i.e. error or found) depends on the type of the rule
(i.e. check or search).  It is also possible to locally disable rules
for a part of the source code, and various options can be passed to
the program.

Ex:

Given the following package:
@example
@b{package} Pack @b{is}
   @b{pragma} Pure (Pack);
   ...
@b{end} Pack;
@end example
The following command:
@example
adactl -l "search pragmas (pure)" pack
@end example
produces the following result (displayed to standard output):
@example
pack.ads:2:4: Found: PRAGMAS: use of pragma Pure
@end example

Caveat:

If your project includes source files located in several directories,
the ADA_INCLUDE_PATH environment variable is not always considered by
ASIS, resulting in error messages that tell you that the bodies of
some units have not been found (and hence have not been
processed). This problem has been fixed in  Gnat dated later than
Sept. 1st, 2006. If this happens, either provide your source
directories as ``-I'' options (@pxref{ASIS options}), or generate the
tree files manually (@pxref{Generating tree files manually}). Note
that this problem does not happen if you are using Emacs project files
(@pxref{Project files}), nor if you are running AdaControl from GPS.

AdaControl can process only Ada-95, not Ada-2005, since there no ASIS
for Ada-2005 yet.  If you are using a version of GNAT where Ada-2005
is the default (especially GNAT-GPL), and in the rare cases where your
program would not compile in Ada-2005 mode (notably if you have a
function that returns a task type), you must force Ada-95 mode by
having a ``gnat.adc'' file that contains a @code{@b{pragma} Ada_95},
since the corresponding option cannot be passed to the compiler in
``compile on the fly'' mode. Alternatively, you can generate the
tree files manually (@pxref{Generating tree files manually}) with the
``-gnat95'' option.

@node Running AdaControl from GPS, Running AdaControl from AdaGide, Running AdaControl from the command line, Program Usage
@section Running AdaControl from GPS
If you want to use AdaControl from GPS, make sure you have copied the
necessary files into the required places. @xref{Installing AdaControl}.

AdaControl integrates nicely into GPS, making it even easier to
use. It can  be launched from menu commands, and parameters can be set
like any other GPS project parameters.  When run from within GPS,
AdaControl will automatically retrieve all needed directories from the
current GPS project.

After running AdaControl, the ``locations'' panel will open, and you
can retrieve the locations of errors from there, just like with a
regular compilation. Errors will be marked in red in the source,
warning will be marked orange, and you will have corresponding marks
showing the places of errors and warnings in the speedbar. Note that
AdaControl errors appear under the ``AdaControl'' category, but if
there were compilation errors, they will appear under the
``Compilation'' category. Final counts from ``count'' rule types will
appear under the ``Counts summary'' category.

@menu
* The AdaControl menu and buttons::  
* Contextual menu::             
* AdaControl switches::         
* AdaControl preferences::      
* AdaControl language::         
* AdaControl help::             
@end menu

@node The AdaControl menu and buttons, Contextual menu, Running AdaControl from GPS, Running AdaControl from GPS
@subsection The AdaControl menu and buttons
GPS now features an ``AdaControl'' menu, with several submenus:
@itemize @bullet
@item
``Control Current File (rules file)'' runs AdaControl on the currently
edited file, with rules taken from the current rules file; this menu
is greyed-out if no rules file is defined, if no file window is
currently active, or if the associated language is not ``Ada''. The
name of the rules file can be set from the ``Library'' tab from the
``Project/Edit Project Properties'' menu.
@item
``Control Root Project (rules file)'' runs AdaControl on all units
that are part of the root project, with rules taken from the current
rules file; this menu is greyed-out if no rules file is defined. The
name of the rules file can be set from the ``Library'' tab from the
``Project/Edit Project Properties'' menu.
@item
``Control Units from List (rules file)'' runs AdaControls on units
given in a indirect file, with rules taken from the current rules
file. This menu is greyed-out if no rules file is defined or if no
indirect file is defined. The name of the rules file and of the
indirect file can be set from the ``Library'' tab from the
``Project/Edit Project Properties'' menu.
@item
``Control Current File (interactive)'' runs AdaControl on the
currently edited file, with a rule asked interactively from a pop-up;
this menu is greyed-out if no file window is currently active, or if
the associated language is not ``Ada''.
@item
``Control Root Project (interactive)'' runs AdaControl on all units
that are part of the root project, with a rule asked interactively
from a pop-up.
@item
``Control Units from List (interactive)'' runs AdaControls on units
given in a indirect file, with a rule asked interactively from a
pop-up. This menu is greyed-out if no indirect file is defined. The
name of the indirect file can be set from the ``Library'' tab from the
``Project/Edit Project Properties'' menu.
@item
``Check Rules File'' checks the syntax of the current rules file. This
menu is deactivated if the current window does not contain an
AdaControl rules file.
@item
``Open Rules File'' opens the rules file. This menu is deactivated if
there is no current rules file defined.
@item
``Open Units File'' opens the units file. This menu is deactivated if
there is no current units file defined.
@item
``Delete Tree Files'' removes existing tree files from the current
directory.  This is convenient when AdaControl complains that the tree
files are not up-to-date. Note that you can set the preferences for
automatic deletion of tree files after each run (see below). Note that
the name of this menu is changed to ``Delete Tree and .ali Files'' if
you have chosen to delete .ali files in the preferences (see below).
@item
``Create .adp project'' create an Emacs-style project file from the
current GPS project, which can be used with the ``-p'' option if you
want to run AdaControl from the command line. This file has the same
name as the current GPS project, with a ``.adp''
extension. @xref{Project files}.
@end itemize

There are also two buttons representing Lady Ada in a magnifier glass
in the toolbar, one with a red question mark in the background. These
buttons launch AdaControl, by default on the file currently being
edited; however, you can change this behaviour from the preferences to
control either files from a list, or all files from the project. The
button without the question mark uses rules from the current rules
file, while the one with the question mark asks the rule
interactively.

Here are some tips about using the ``interactive'' menus (or the
button with the question mark):
@itemize @bullet
@item
When you use the ``interactive'' menus several times, the
previously entered command(s) is used as a default.
@item
You can enter any command from AdaControl's language in the dialog;
you can even enter several commands separated by ``;''.
@item
Especially, if you want to run AdaControl with a rules file that is
not the one defined by the switches, you can use one of the
``interactive'' commands, and give ``source <file name>'' as the
command.
@end itemize

@node Contextual menu, AdaControl switches, The AdaControl menu and buttons, Running AdaControl from GPS
@subsection Contextual menu
AdaControl adds two entries to the contextual menus (right click) of
Ada files.  They call the @code{pfni} utility on the current
entity. @xref{pfni}.  The entry ``Print full name'' displays the full
name of the entity in simple form, while the entry ``Print full name
(with overloading)'' ) prints it with overloading information.

This is convenient to find how to name entities in rule
files. @xref{Specifying an Ada entity name}. It is also convenient to
find where an entity is declared, and which of several overloaded
entities is being referred to.

@node AdaControl switches, AdaControl preferences, Contextual menu, Running AdaControl from GPS
@subsection AdaControl switches
The tab ``switches'' from the ``Project/Edit Project Properties'' menu
includes a page for AdaControl, which allows you to set various
parameters.
@itemize @bullet
@item
``Recursive mode''. This sets the ``-r'' option. @xref{Input units}.
@item
``Ignore local deactivation''. This sets the ``-r''
option. @xref{Local deactivation ignoring}.
@item
``Process specs only''. This sets the ``-s'' option. @xref{Input
units}.
@item
``Compilation unit mode''. This sets the ``-u'' option. @xref{Input
units}.
@item
``Display only errors''. This sets the ``-E'' option. @xref{Treatment
of warnings}.
@item
``Warnings as errors''. This sets the ``-e'' option. @xref{Treatment
of warnings}.
@item
``Statistics''. This sets the ``-S'' option from a pull-down
menu. @xref{Rule types and report messages}.
@item
``Send results to GPS''. When checked (default), the output of
AdaControl is sent to the ``locations'' window of GPS.
@item
``Send results to File''. When checked, the output of AdaControl is
sent to the file indicated in the box below.
@item
``File name''. This is the name of the file that will contain the
results when the previous button is checked.  If the file exists,
AdaControl will ask for the permission to overwrite it.
@item
``File format''. This is a pull-down menu that allows you to select
the desired format when output is directed to a file (``-F'' option).
@xref{Rule types and report messages}.
@item
``Debug messages''. This sets the ``-d'' option. @xref{Verbose and
debug mode}.
@item
``Halt on error''. This sets the ``-x'' option. @xref{Exit on error}.
@end itemize
Since the GPS interface analyzes the output of AdaControl, you should
not set options directly in the bottom window of this page.

@node AdaControl preferences, AdaControl language, AdaControl switches, Running AdaControl from GPS
@subsection AdaControl preferences
There is an entry for AdaControl in the ``edit/preferences'' menu:
@itemize @bullet
@item
``delete trees''. If this box is checked, tree files are automatically
deleted after each run of AdaControl. This avoids having problems with
out-of-date tree files, at the expanse of slightly slowing down
AdaControl if you run it several times in a row without changing the
source files.
@item
``Delete .ali files with tree files''. If this box is checked, the
``.ali'' files in the current directory will also be deleted together
with the tree files (either automatically if the previous box is
checked, or when the ``AdaControl/Delete Tree Files'' menu is
selected). This is normally what you want, unless the current
directory is also used as the object directory for compilations; in
the latter case, deleting ``.ali'' files would cause a full
recompilation for the next build of the project.
@item
``Help on rule''. This allows you to select how rule specific help
(from the ``Help/AdaControl/Help on rule'' menu) is displayed. If you
select ``Pop-up'', a summary of the rule's purpose and syntax is
displayed in a pop-up. If you select ``User Guide'', the user guide
opens in a browser at the page that explains the rule. (Caveat: due to
a problem in GPS, the browser does not find the right anchor;
hopefully, this will be fixed in an upcomming release of GPS).
@item
``Use separate categories''. If this box is checked, there will be one
category (i.e. tree in the locations window) for each rule type or
label, otherwise all messages will be grouped under the single
category ``AdaControl''. In practice, this means that with the box
checked, messages will be sorted by rules first, then by files, while
otherwise, the messages will be sorted by files first, then by rules.
In any case, compilation errors appear under the ``Compilation''
category, and final counts under the ``Counts summary'' category.
@item
``Auto save files''. If this box is checked, all modified files are
automatically saved without asking before running
AdaControl. Otherwise, a dialog appears allowing the user to choose
which files to save.
@item
``Buttons operate on''. This defines the behaviour of the buttons.
If ``Current File'' is selected, the buttons operate on the file being
currently edited. If ``Root Project'' is selected, the buttons operate
on all files that are part of the current project. If ``Units from List''
is selected, the buttons operate on all units from the units file.
@end itemize

@node AdaControl language, AdaControl help, AdaControl preferences, Running AdaControl from GPS
@subsection AdaControl language
If you check ``AdaControl'' in the ``Languages'' tab, GPS
will recognize files with extension @code{.aru} as AdaControl rules
files, and provide appropriate colorization.

@node AdaControl help,  , AdaControl language, Running AdaControl from GPS
@subsection AdaControl help
The AdaControl User Manual (this manual) and the AdaControl
Programmer Manual are available from the "Help/AdaControl" menu of GPS. In addition,
there is a "Help on rule" entry in this menu. This entry displays the list of
all rules; if you click on one of them, it displays the rule(s)
purpose and the syntax of its parameters.

@node Running AdaControl from AdaGide, Rules syntax, Running AdaControl from GPS, Program Usage
@section Running AdaControl from AdaGide
If you want to use AdaControl from AdaGide, make sure you have copied
the necessary file into the required place. @xref{Installing
AdaControl}. Note that AdaGide does not have all the parameterization
facilities of sophisticated environments like GPS, but all AdaControl
options, like the name of  the rules file or the output format, can
easily be changed by editing the tool description file
@code{AdaControl.tdf}.

AdaGide now features several AdaControl commands from the ``tool'' menu:
@itemize @bullet
@item
``AdaControl'' runs AdaControl on the currently
edited file, with rules taken from the file named @code{verif.aru}.
@item
``AdaControl recursive'' works like the previous command, with the
addition of the ``-r'' (recursive) option. When used on the main
program, it will analyze the whole set of compilation units in the
program.
@item
``AdaControl interactive'' runs AdaControl on the currently
edited file, with a rule asked interactively from a pop-up.
@item
``AdaControl: delete .adt'' removes existing tree files from the
current directory.  This is convenient when AdaControl complains that
the tree files are not up-to-date.
@end itemize

@node Rules syntax, Commands, Running AdaControl from AdaGide, Program Usage
@section Rules syntax
AdaControl is about @i{checking rules}. Each rule has a name, and may
require parameters. Which rules are to be checked is specified either
on the command line or in a rules file; in either case, the syntax for
specifying rules is as follows:
@example
[<label> ":"] "check"|"search"|"count" <Name>
    ["(" [<modifiers>] <parameter> @{"," [<modifiers>] <parameter>@}")"] ";"
@end example

If present, the label gives a name to the rule; it will be printed
whenever the rule is activated, and can be used to disable the rule.
@xref{Disabling rules}. If no label is present, the rule name is
printed instead. The label must have the syntax of an Ada identifier,
or else the label must be included within double quotes (@code{"}), in
which case it can contain any character. Note that there is no
problem in specifying the same label for several rules.

Each rule consists of a rule type followed by a rule name, and
(optionally) parameters. Some parameters may be preceded by modifiers
(such as ``not'' or ``case_sensitive''). The meaning of the rule
parameters and modifiers depends on the rule. The case of the rule
type, rule name, and parameters is not significant. If a syntax error
is encountered in a rule, an appropriate error message is output, and
analysis of the rules file continues in order to output all errors,
but no analysis of user code will be performed.

Since wide characters are allowed in Ada programs, AdaControl accepts
wide characters in rules as well. With GNAT, the encoding scheme is
Hex ESC encoding (see the GNAT User-Guide/Reference-Manual). This is
the prefered method, since few people require wide characters in
programs anyway, and that keeping the default bracket encoding would
not conveniently allow brackets for regular expressions, like those
used by some rules. @xref{Syntax of regular expressions}.

@menu
* Rule types and report messages::  
* Parameters::                  
* Specifying an Ada entity name::  
* Multiple rules::              
@end menu

@node Rule types and report messages, Parameters, Rules syntax, Rules syntax
@subsection Rule types and report messages
There are three rule types:

@itemize
@item
check
@item
search
@item
count
@end itemize

``Check'' is intended to search for rules that must be obeyed in your
programs. Normally, if a ``Check'' rule fails, you should fix the
program. ``Search'' is intended to report some situations, but you
should consider what to do on a case-by-case basis. Roughly, use
``check'' when you consider that the failure of the rule is an error,
and ``search'' when you consider it as a warning. AdaControl will exit
with a status of 1 if any ``Check'' rule is triggered, and a status of
0 if only ``Search'' rule were triggered (or no rule was triggered at
all).

``Count'' works like ``search'', but instead of printing a message for
each rule which is triggered, it simply counts occurrences and prints
a summary at the end of the run. There is a separate count for each
rule label (or if no label is given, the rule name is taken instead);
if you give the same label to different rules, this allows you to
accumulate the counts.

A report message (except for the final report of ``count'') comprises
the following elements:
@itemize
@item
the file name (where the rule matches)
@item
the line number (where the rule matches)
@item
the column number (where the rule matches)
@item
the rule label (if there is one) and/or the rule id (the rule that matches).
@item
a message (why the rule matches). A rule whose type is ``check'' will
produce an error report message (i.e. containing the keyword ``Error'')
and a rule use whose type is ``search'' will produce a found report
message (i.e. containing the keyword ``Found'').
@end itemize

The formatting of the report message depends on the format option,
which can be selected with the ``-F'' command-line option or the ``set
format'' command.

If the format is ``Gnat'' (the default) or ``Gnat_Short'', items are
separated by ':'; this is the same format as the one used by GNAT
error messages. Editors (like Emacs or GPS) that recognize this format
allow you to go directly to the place of the message by clicking on
it.  In order to avoid too long messages, only the rule label appears,
unless there is none, in which case it is replaced with the rule id.

If the format is ``CSV'' or ``CSV_Short'', items are separated by ','
and surrounded by double quotes. This is the ``Comma Separated
Values'' format, which can be read by any known spreadsheet program,
except Excel(tm), which uses the semicolon and not the comma to
separate fields. Therefore, the formats ``CSVX'' and ``CSVX_Short'' do
the same thing, but using semi-colons (';') instead of commas. Both
the rule label (replaced by an empty column if there is none) and the
rule id appear. Note that when an output file is created in one of the
``CSV'' formats, a title line is issued as the first line, following
normal CSV convention.

If the format is ``Source'' or ``Source_Short'', the offending source
line is output, and the message is output behind it, with a ``!''
pointing to the exact location of the problem.

If the format is ``None'', no error message is output at all. This is
useful when only the return code of running AdaControl is desired (just
to check if a program is OK or not). Note that this does @i{not} prevent
the output of statistics, since these are under control of the ``-S''
option or the ``set statistics'' command.

With recent versions of Gnat, the file name includes the full path of
the source file. If the ``_Short'' form of the format option is used,
the file name is stripped from any path. This can make it easier to
compare the results of controlling units from various directories.
Note that with older versions of Gnat, the file name never includes
the full path, and the ``_Short'' form of the format option has no
effect.

After each ``go'' command, statistics may be output, depending on the
statistics level which is set with the ``-S'' option or the ``set
statistics'' command. The meaning of the various levels is as follows:
@itemize
@item
0: No statistics are output (default)
@item
1: A count of error and warning messages is output
@item
2: The rule name and label (if any) of any rule @i{not} triggered are
output
@item
3: The rule name and label (if any) of every rule is output, together
with a count of each triggering type (check, search, count), or ``not
triggered'' if the rule was not triggered.
@end itemize

@node Parameters, Specifying an Ada entity name, Rule types and report messages, Rules syntax
@subsection Parameters
Most rules accept parameters. Parameters can be:
@itemize
@item
a keyword for the rule
@item
a numerical value
@item
a character string (often a regular expression)
@item
an Ada entity name
@end itemize

A numerical value is given with the syntax of an Ada integer or real
literal (underscores are allowed as in Ada). Based literals are not
currently supported; if somebody can justify a need for them, we'll be
happy to add this feature later...

A character string is given within double quotes ``"''. As usual, quotes
appearing within the string are doubled. The tilde character (``~'') can be
used as a replacement delimiter, but the same character must be used at both
ends of the string. The latter has been chosen as a character not used
by the various shells, and can be useful to pass quoted strings from
parameters on the command line (unfortunately, we could not use the
percent (``%'') sign, because it plays a special role in DOS/Windows).

An Ada entity name can be followed by overloading information (see
below), in order to uniquely identify the Ada entity. If an Ada
entity is overloaded and no overloading information is provided, the
rule is applied to all (overloaded) Ada entities that match the name.

@node Specifying an Ada entity name, Multiple rules, Parameters, Rules syntax
@subsection Specifying an Ada entity name
The syntax of the <Ada_Entity_Name> is as follows:
@example
<Ada_Entity_Name> ::= <Full_Name> | "all" <Simple_Name> | "all" <Attribute>
@end example
@code{<Full_Name>} is the full name of the Ada entity, using normal
Ada dot notation (with some extensions, see below)). Full name means
that you give the full expanded name, starting from a compilation
unit. This name must be the actual full name, i.e. it must not include
any renaming (otherwise the name will not be recognized). For example,
the usual @code{Put_Line} must be given as
@code{Ada.Text_IO.Put_Line}, not as
@code{Text_IO.Put_Line}. Predefined elements (@code{Integer},
@code{Constraint_Error}) must be given in the form
@code{Standard.Integer} or @code{Standard.Constraint_Error}, since
they are logically declared in the package @code{Standard}.

@code{<Simple_Name>} is a single identifier, possibly followed by
overloading information. No qualification is allowed.

@code{<Attribute>} is an attribute name, including the quote. No
overloading information is allowed.

@code{<Full_Name>} designates a single entity or several overloaded
entities declared in the same place (as identified by the prefix),
while @code{all <simple_name>} designates all identifiers with the
given name in the program, irrespectively of where they
appear. @code{all <Attribute>} designates all occurrences of the given
attribute, irrespectively of what the attribute applies to.

A utility is provided with AdaControl to help you find the full name
of an entity. @xref{pfni}. If you are using GPS with AdaControl
plug-ins, it can be accessed directly from the contextual
menu. @xref{Contextual menu}.

@subsubsection Overloaded names
In Ada, names can be overloaded. This means that you can have several
procedures @code{P} in package @code{ Pack}, if they differ by the
types of the parameters. If you just give the name @code{Pack.P} as
the <Ada_Entity_Name>, the corresponding rule will be applied to all
elements named @code{P} from package @code{Pack}. If you want to
distinguish between overloaded names, you can specify a profile after
the element's name. A profile has the syntax:

@example
"@{" [ ["access"] <type-name>
     @{ ";" ["access"] <type-name> @} ]
     ["return" <type-name>] "@}"
@end example

You must specify the @i{type} name, even if the <Ada_Entity_Name>
declaration uses a subtype of the type; this is because Ada uses types
for overloading resolution, not subtypes. Anonymous access parameters
are specified by putting @code{access} in front of the type name. An
overloaded name for a procedure without parameters uses just a pair of
empty brackets. If the subprogram is a function, you must provide the
@code{return <type-name>} part for the return type of the
function. The types must also be given as a unique name,
i.e. including the full path: if the type is @code{T} declared in
package @code{Pack}, you must specify it as @code{Pack.T}. As a
convenience, the @code{Standard.} is optional for predefined types, so
you can write @code{Standard.Integer} as @code{Integer}. There is no
ambiguity, since a type is always declared within some construct. Note
that omitting @code{Standard} works only for @i{types} that are part
of the profile used to distinguish between overloaded Ada entities but
that the @i{Ada entity name} must always contain Standard if it is a
predefined element.

Overloaded names can be also be used with the @code{all <Simple_Name>}
form of the <Ada_Entity_Name>. In this case, the rule will be applied to
all names that are subprograms with the given identifier and matching
the given profile, irrespectively of where they appear.

Note that if you use an overloaded name, all overloadable names that
are part of the <Ada_Entity_Name>, including those of the profile, must
use the overloaded syntax. For example, given the following program
@example
@b{procedure} P @b{is}
   @b{procedure} Q (I : Integer) @b{is}
      ...
   @b{end} Q;
   @b{procedure} Q (F : Float) @b{is}
      ...
   @b{end} Q;
@b{begin}
   ...
@b{end} P;
@end example

If you want to distinguish between the two procedures @code{Q}, you
must specify them as @code{P@{@}.Q@{Integer@}} and
@code{P@{@}.Q@{Float@}} (note the @code{P@{@}} which specifies an
overloaded name for a procedure @code{P} without parameters).

The names of entities which can not be overloaded (like package,
exception, @dots{}) must not  be suffixed by braces
(e.g. @code{Ada.Text_IO.Put_Line@{Standard.String@}}).

@subsubsection Enumeration literals
Following normal Ada rules, an enumeration literal is considered a
parameterless function. If you want to distinguish between overloaded
enumeration literals, you can use overloaded names for them. For
example, given:
@example
@b{package} Pack @b{is}
   @b{type} T1 @b{is} (A, B);
   @b{type} T2 @b{is} (B, C);
@b{end} Pack;
@end example

Ada entities names are:
@itemize
@item
@code{Pack.B@{return Pack.T1@}}
@item
@code{Pack.B@{return Pack.T2@}}
@end itemize

@subsubsection Operators
AdaControl handles operators (i.e. functions like @code{"+"})
correctly. Of course, you must specify such operations using normal
Ada syntax: if you define the integer type @code{T} in package
@code{Pack}, an overloaded name for the addition would be
@code{Pack."+"@{Pack.T; Pack.T return Pack.T@}}.

@subsubsection Attributes
It is also possible to designate attributes, using the normal notation
(i.e. @code{Standard.Integer'First}). If the name of an attribute which
is a function appears in a name that uses the overloaded syntax, it is
not necessary (and actually not allowed) to provide its profile, since
there is no possible ambiguity in that case. For example, given:

@example
@b{procedure} P (I : Integer) @b{is}
   @b{type} T @b{is} @b{range} 1 .. 10;
@b{begin}
   ...
@b{end} P;
@end example

You can designate the @code{'Image} attribute for type @code{T} as
@code{P@{Standard.Integer@}.T'Image} (the profile of the @code{'Image}
function is not given, as would be necessary for a normal function).

@subsubsection Anonymous constructs
There is a special case for elements that are defined (directly or
indirectly) within unnamed loops or block statements. Everything
happens as if the unnamed construct was named @code{_anonymous_}. So
if you have the following program:
@example
@b{procedure} P @b{is}
@b{begin}
   @b{for} I @b{in} 1..10 @b{loop}
      @b{declare}
         J : Integer;
      @b{begin}
         ...
      @b{end};
   @b{end} @b{loop};
@b{end} P;
@end example
You can refer to @code{I} as @code{P._anonymous_.I}, and to @code{J}
as @code{P._anonymous_._anonymous_.J}.

@subsubsection Record and protected types components
You can designate the name of a record or protected type component (a
``field'' name), but to identify it uniquely, you must precede its name
by the name of the type. This is a small extension to Ada syntax, but
it is the simplest and most natural way to deal with this case. For
example, given:
@example
@b{procedure} P @b{is}
   @b{type} T @b{is}
      @b{record}
         Name : Integer;
      @b{end} @b{record};
   ...
@end example

The Ada entity name is @code{P.T.Name}.

@subsubsection Formals of access to subprogram types
Similarly, you can designate the formal of an access to subprogram
type by prefixing it by the access type. For example, given:
@example
@b{procedure} P @b{is}
   @b{type} T @b{is} @b{access} @b{procedure} (X : Integer);
   ...
@end example

The Ada entity name of the formal is @code{P.T.X}.

@subsubsection Limitation
Due to a limitation of ASIS for Gnat, it is not possible to specify
a profile with predefined operators; predefined operators without
a profile work normally.
@example
-- This will not recognize "<" on Standard.Integer:
check entities (Standard."<"@{Standard.Integer,
                             Standard.Integer
                             return Standard.Boolean@});

-- This will correctly recognize all predefined "<":
check entities (Standard."<");
@end example

@node Multiple rules,  , Specifying an Ada entity name, Rules syntax
@subsection Multiple rules
Most rules can be given more than once (with different
parameters). There is no difference between a single or a multiple
configuration rule use: outputs, efficiency, etc. are the same.

The following configuration files produce an identical configuration:
@example
Search Pragmas (Pure, Elaborate_All);
@end example
and
@example
Search Pragmas (Pure);
Search Pragmas (Elaborate_All);
@end example

However, the second form can be used to give different labels. Consider:
@example
Search Pragmas (Pure);
No_Elaborate: Search Pragmas (Elaborate_All);
@end example

The messages for pragma @code{Pure} will contain ``PRAGMAS'', while
those for @code{Elaborate_All} will contain ``No_Elaborate''. If a
disabling comment mentions @code{pragmas}, it will disable both rules,
but a disabling comment that mentions @code{No_Elaborate} will disable
only the second one.

@node Commands, Command line options and parameters, Rules syntax, Program Usage
@section Commands
In addition to rules specification, AdaControl recognizes a number of
commands. Although these commands are especially useful when using the
interactive mode (@pxref{Interactive mode}), they can be used in
command files as well.

@menu
* Go command::                  
* Quit command::                
* Message command::             
* Help command::                
* Clear command::               
* Set command::                 
* Source command::              
* Inhibit command::             
* Example of commands::         
@end menu

@node Go command, Quit command, Commands, Commands
@subsection Go command
Syntax:
@example
go;
@end example
This command starts processing of the rules that have been
specified. Rules are @i{not} reset after a ``go'' command; for
example, the following program:
@example
search entities (pack1);
go;
search entities (pack2);
go;
@end example
will first output all usages of @code{Pack1}, then all usages of both
@code{Pack1} and @code{Pack2}. See @ref{Clear command} to reset rules.

If not in interactive mode, a ``go'' command is automatically added,
therefore it is not required in rules files.

@node Quit command, Message command, Go command, Commands
@subsection Quit command
Syntax:
@example
quit;
@end example
This command terminates AdaControl. If given in a file, all subsequent
commands will be ignored. This command is really useful only in
interactive mode. @xref{Interactive mode}.

@node Message command, Help command, Quit command, Commands
@subsection Message command
Syntax:
@example
message "<any string>";
@end example
This command prints the given message on the output file. The length
of the message is limited to 250 characters.

Note that the message is syntactically a string, and must therefore be
quoted (double quotes).

@node Help command, Clear command, Message command, Commands
@subsection Help command
Syntax:
@example
Help [ all | <rule name>@{,<rule name>@} ];
@end example
Without any argument, this command prints a summary of all commands
and rule names. If given one or more rule names, it prints the
detailed help for the given rules. If given the keyword @code{all}, it
prints the detailed help for all rules.

@node Clear command, Set command, Help command, Commands
@subsection Clear command
Syntax:
@example
Clear all | <rule name>@{,<rule name>@} ;
@end example
This command clears all ``count'', ``search'', and ``check'' commands
given for the indicated rules, of for all rules if the @code{all}
keyword is given. For example, the following program:
@example
search entities (pack1);
go;
clear all;
search entities (pack2);
go;
@end example
will first output all usages of @code{Pack1}, then all usages of
@code{Pack2}. Without the ``clear all'' command, the second ``go''
would output all usages of @code{Pack1} together with all usages of
@code{Pack2}.

@node Set command, Source command, Clear command, Commands
@subsection Set command
Syntax:
@example
set Format Gnat|Gnat_Short|CSV|CSV_Short|Source|Source_short|None
set Output <output file>;
set Statistics <level>
set Trace <trace file>;
set Verbose|Debug|Ignore|Warning  On|Off
@end example
In the first form, this commands selects the output format for the
messages, like the ``-F'' option; see @ref{Rule types and report messages}
for details.

In the second form, this command redirects the output of subsequent
checks to the indicated file. If the string @code{console} (case
irrelevant) is given as the <output file>, output is redirected to the
console.

As with the ``-o'' option, if the file exists, output is appended to it,
unless the ``-w'' option is given, in which case it is
overwritten. However, the file is overwritten only the first time it
is mentionned in an ``output'' command. This means that you can switch
forth and back between two output files, all results from the same run
will be kept. Note however that for this to work, you need to specify
the output file exactly the same way: if you specify it once as
``result.txt'', and then as ``./result.txt'', the second one will
overwrite the first one.

In the third form, this command redirects the trace messages of the
``-d'' option to the indicated file. If the string @code{console}
(case irrelevant) is given as the <trace file>, trace messages are
redirected to the console.  As with the ``-t'' option, if the file
exists, output is appended to it.

In the fourth form, this command allows to set the statistics level,
like the ``-S'' option;  see @ref{Rule types and report messages} for
details.

In the fifth form, this command allows to activate (``on'') or
deactivate (``off'') options. ``Verbose'' corresponds to the ``-v''
option, ``Debug'' to the ``-d'' option, ``Ignore'' to the ``-i''
option, and ``Warning'' to the ``-E'' option. See @ref{Verbose and
debug mode}, @ref{Treatment of warnings}, and @ref{Local deactivation
ignoring} for details.

@node Source command, Inhibit command, Set command, Commands
@subsection Source command
Syntax:
@example
Source <input file>;
@end example
This command redirects the input of commands from the indicated
file. Commands and rules are read and executed from the indicated
file, then control is returned to the place after the ``source''
command. There is no restriction on the content of the sourced file;
especially, it may itself include other ``source'' commands.

If <input file> is a relative file path, it is taken relatively to the
file where the ``source'' command is given. Especially, if no path is
specified, the sourced file will be taken from the same directory as
the sourcing file (irrespectively of where the command is being run
from).

If the string @code{console} (case irrelevant) is given as the <input
file>, commands are read from the console until a ``quit'' command is
given. This command is of course useful only from files, and allows to
pass temporarily control to the user in interactive mode.

@node Inhibit command, Example of commands, Source command, Commands
@subsection Inhibit command
Syntax:
@example
Inhibit <rule name>|all ([all] <unit> @{,[all] <unit>@});
@end example
This command will inhibit execution of the rule (or all rules if
``all'' is specified in place of a rule name) for the indicated
unit(s). In addition, if ``all'' is given in front of the unit name,
the unit will not be accessed at all, even from rules that follow call
graphs, and could thus access this unit while analyzing other units.

There are several reasons why you might want to inhibit a rule for
certain units:
@itemize
@item
The unit is known not to obey the rule in many places, and you don't
want the output to be cluttered with too many messages (of course,
you'll fix the unit in the near future!);
@item
The unit is known to obey the rule, and you want to save some
processing time;
@item
The unit is known to raise an ASIS bug, and until you upgrade to the
appropriate version of GNAT, you don't want to be bothered by the
error messages.
@end itemize

The ``all'' option is intended for the last case, to prevent ASIS bugs
from spoiling any unit that calls something from an offending unit.

@node Example of commands,  , Inhibit command, Commands
@subsection Example of commands
Below is an example of a file with multiple commands:
@example
message "Searching Unchecked_Conversion";
search entitities (ada.unchecked_conversion);
set output uc_usage.txt;
go;
clear all;
message "Searching 'Address";
search entities (all 'Address);
set output address_usage.txt;
go;
@end example
This file will output all usages of @code{Ada.Unchecked_Conversion}
into the file @code{uc_usage.txt}, then output all usages of the
@code{'Address} attribute into the file
@code{address_usage.txt}. Messages are output to tell the user about
what's happenning.

@node  Command line options and parameters, Return codes, Commands, Program Usage
@section Command line options and parameters
Options are introduced by a ``-'' followed by a letter and can be
grouped as usual. Some options take the following word on the command
line as a value; such options must appear last in a group of
options. Parameters are words on the command line that stand by
themselves. Options and parameters can be given in any order.

The complete syntax for invoking AdaControl is:

@example
adactl [-deEiIrsuvw] [-f <rules file>] [-l <rules list>] [-o <output file>]
       [-F <format>] [-p <project file>] [-S <statistics level>]
       @{<unit>[+|-<unit>]|[@@]<file>@} [-- <ASIS options>]
@end example
or
@example
adactl -h [<rule id>... | all]
@end example
or
@example
adactl -C [-v] [-f <rules file>] [-l <rules list>]
@end example
or
@example
adactl -D [-rsw] [-o <output file>] [-p <project file>]
          @{<unit>[+|-<unit>]|[@@]<file>@} [-- <ASIS options>]
@end example
Using AdaControl with the ``-D'' option is described later. @xref{Helpful utilities}.
@menu
* Getting help::                
* Checking rules syntax::       
* Input units::                 
* Specifying rules::            
* Output file::                 
* Output format::               
* Interactive mode::            
* Local deactivation ignoring::  
* Verbose and debug mode::      
* Treatment of warnings::       
* Exit on error::               
* Project files::               
* ASIS options::                
@end menu

@node Getting help, Checking rules syntax, Command line options and parameters, Command line options and parameters
@subsection Getting help
The ``-h'' option alone displays a help message about usage of the
AdaControl program, the various options,  and  the rule names.  If the
``-h'' is followed by one or several rule names (case irrelevant), it
displays the help message for the rule(s). If the ``-h'' option is
followed by the keyword ``all'', it displays the help message for all
rules. If the ``-h'' option is followed by the keyword ``list'', it
simply lists the names of all rules (note that ``-h'' without parameters
also displays the list of rules, in a prettier format; this option is
mainly useful for the integration of AdaControl into GPS).

Ex:
@example
adactl -h
adactl -h pragmas Unnecessary_Use_Clause
adactl -h all
@end example
Note that if the ``-h'' option is given, no other option is analyzed
and no further processing happens.

@node Checking rules syntax, Input units, Getting help, Command line options and parameters
@subsection Checking rules syntax
If the ``-C'' option is given, AdaControl will simply check the syntax
of the rule provided with the ``-l'' option, or of the rules provided
in the file named by the ``-f'' option (at least one of these options
must be provided). No other processing will happen.

AdaControl will exit with a return code of 0 if the syntax is correct,
and 2 if any errors are found. A confirming message that no errors
were found is output if the ``-v'' option is given.

This option is especially useful when you have modified a rules file,
before trying it on many units. The way AdaControl works, it must open
the ASIS context (a lengthy operation) @i{before} analyzing the
rules. This option can therefore save a lot of time if the rules file
contains errors.

@node Input units, Specifying rules, Checking rules syntax, Command line options and parameters
@subsection Input units
Units to be processed are simply given as parameters on the command
line. Note that they are Ada compilation unit names, not file names:
case is not significant, and there should be no extension! Of course,
child units  are allowed following normal Ada naming rules:
@code{Parent.Child}, but be aware that specifying a child unit will
automatically include its parent unit in the analysis.  All subunits
are processed during the analysis of the including unit; there is
therefore no need to specify subunits explicitely. If you do specify a
subunit explicitly, it will result in the whole enclosing unit being
analyzed.

However, as a convenience to the user, units can be specified as file
names, provided they follow the default GNAT naming convention. More
precisely, if a parameter ends in ``.ads'' or ``.adb'', the unit name
is extracted from it (and all ``-'' in the name are substituted with
``.''). File names can include a path; in this case, the path is
automatically added to the list of directories searched (``-I''
option). The file notation is convenient to process all units in a
directory, as in the following example:
@example
adactl -f my_rules.aru *.adb
@end example

In the unlikely case where you have a child unit called @code{Ads} or
@code{Adb}, use the ``-u'' option to force interpretation of all
parameters as unit names.

By default, both the specification and body of the unit are processed;
however, it is possible to specify processing of the specification
only by providing the ``-s'' option. If only file names are given, the
``-s'' option is assumed if all files are specifications (``.ads''
files). It is not possible to specify processing of bodies only, since
rules dealing with visibility would not work.

The ``-r'' option tells AdaControl to process (recursively) all user
units that the specified units depend on (including parent units if
the unit is a child unit or a subunit). Predefined Ada units and units
belonging to the compiler's run-time library are never processed.

Ex:
@example
adactl -r -f my_rules.aru my_main
@end example
will process @code{my_main} and all units that @code{my_main} depends
on. If @code{my_main} is the main procedure, this means that the whole
program will be processed.

It is possible to specify more than one unit (not file) to process in
a parameter by separating the names with ``+''.  Conversely, it is
possible to specify units that are @i{not} to be processed, separated
by ``-''. When a unit is subtracted from the unit list, it is never
processed even if it is included via the recursive option, and all its
child and separate units are also excluded. This is convenient to
avoid processing reusable components, that are not part of a
project. For example, if you want to run AdaControl on itself, you
should use the following command:
@example
adactl -f my_rules_file.aru -r adactl-asis-a4g
@end example
This applies the rules from the file @code{my_rules_files.aru} to
AdaControl itself, but not to units that are part of ASIS (the ``-r''
(recursive) option would find them otherwise).

Alternatively, it is possible to give a parameter as an ``@@''
followed by the name of a file. This file must contain a list of unit
names (not files), one on each line. All units whose names are given
in the file will be processed. If a name in the file starts with
``@@'', it will also be treated as an indirect file (i.e. the same
process will be invoked recursively). If a line in the file starts
with ``#'' or ``-@w{}-'', it is ignored. This can be useful to
temporarily disable the processing of some files or to add comments.

Ex:
@example
adactl -f my_rules.aru @@unit_file.txt
@end example

@node Specifying rules, Output file, Input units, Command line options and parameters
@subsection Specifying rules
Rules list can be passed on the command line using the ``-l''
option. Rules list must be quoted with ``"''.

Ex:
@example
adactl pack.ads proc.adb -l "check instantiations (My_Generic);"
@end example
It is possible to pass several rules separated by ``;'' as usual, but
as a convenience to the user, the last ``;'' may be omitted.

Rules list can also be passed from a file, whose name must be given
after the ``-f'' option. As a special case, if the file name is ``-'',
rules are read from the standard input. This is intended to allow
AdaControl to be pipelined behind something that generates commands;
if you want to type rules directly to AdaControl, the interactive mode
is more appropriate. @xref{Interactive mode}.

Ex:
@example
adactl -f my_rules.aru proc.adb
@end example

A rule file must contain at least one rule. The layout of rules is
free (i.e. a rule can extend over several lines, and spaces are
allowed between syntactic elements). A rule file may also contain
comment lines. Comments begin with a ``#'' or a ``-@w{}-'', and extend to
the end of the line. Comments can be placed anywhere in the file.

Ex:
@example
# My rules file
# generated by myself 2004.09.27.14.12.36
search rule1 (param1, param2, param3);   -- This is Rule 1
My_Label: check rule2 (param1);
search rule3 (param1,
-- Comment in the middle
              param2,
              param3, param4);
search rule4;   -- A rule without parameters
@end example

Note that the ``-l'' and ``-f'' options are @i{not} exclusive: if both
are specified, the rules to be checked include those in the file and
those given on the command line.

@node Output file, Output format, Specifying rules, Command line options and parameters
@subsection Output file
By default, the standard output is used for output. The default output
can be changed by specifying an output file with the ``-o'' option.

Ex:
@example
adactl -f my_rules.aru -o my_output.txt proc.adb
@end example
Error and found rule messages are output to the output file. Syntax
error messages for rules and possible internal errors from AdaControl
itself are output to the standard error file.

If the output file exists, new messages are appended to it. This
allows running AdaControl under several directories that make up the
project, and gathering the results in a single file. However, if the
``-w'' option is given, AdaControl overwrites the output file if it
exists.

Ex:
@example
adactl -w -f my_rules.aru -o my_output.txt proc.adb
@end example

@node  Output format, Interactive mode, Output file, Command line options and parameters
@subsection Output format
The ``-F'' option selects the output format. It must be followed by
``Gnat'', ``Gnat_Short'', ``CSV'', ``CSV_Short'', ``Source'',
``Source_Short'', or ``None'' (case insensitive).  By default, the output
is in ``Gnat'' format. See @ref{Rule types and report messages} for
details.

The ``-S'' option selects which statistics are output. It must be
followed by a value in the range 0..3.  See @ref{Rule types and report
messages} for details on the various statistics levels.

@example
adactl -F CSV -S 2 -f my_rules.aru -o my_output.csv proc.adb
@end example

@node Interactive mode, Local deactivation ignoring, Output format, Command line options and parameters
@subsection Interactive mode
The ``-I'' option tells AdaControl to operate interactively. In this
mode, commands and rules specified with ``-l'' or ``-f'' options are
first processed, then AdaControl prompts for commands on the
terminal. Note that the ``quit'' command (@pxref{Quit command}) is used
to terminate AdaControl.

The syntax for rules and commands is exactly the same as the one used
for files; especially, each rule or command must be terminated with a
``;''. Note that the prompt (``Command:'') becomes ``.......:'' when
AdaControl requires more input because a command is not completely
given, and especially if you forget the final ``;''.

As with files, it is possible to give several commands on a single
line in interactive mode. Note that if a command contains syntax
errors, all ``go'' commands on the same line are temporarily
disabled. Other commands that do not have errors are normally
processed however.

The interactive mode is useful when you want to do some analysis of
your code, but don't know beforehand what you want to check. Since the
ASIS context is open only once when the program is loaded, queries
will be much faster than running AdaControl entirely with a new query
given in a ``-l'' option each time. It is also useful to experiment
with AdaControl, and to check interactively commands before putting
them into a file.

@node Local deactivation ignoring, Verbose and debug mode, Interactive mode, Command line options and parameters
@subsection Local deactivation ignoring
The ``-i'' option tells AdaControl to ignore deactivation tags
in Ada source code (@pxref{Disabling rules}).

Ex:
@example
adactl -i -f my_rules.aru proc.adb
@end example

@node Verbose and debug mode, Treatment of warnings, Local deactivation ignoring, Command line options and parameters
@subsection Verbose and debug mode
In the default mode, AdaControl displays only rule messages. It is
possible to get more information with the verbose option (``-v''). In
this mode, AdaControl displays unit names as they are processed, and
prints the number of errors, the number of warnings, and its global
execution time when it finishes.

Ex:
@example
adactl -v -f my_rules.aru proc.adb
@end example
It is also possible to get more information in case of a program error
by using the debug mode. Debug mode is enabled by using the ``-d''
option.

Note that in this mode, AdaControl may, in rare occasions (and only
with some versions of Gnat), display ASIS ``bug boxes''; this does not
mean that something went wrong with the program, but simply that an
ASIS failure was properly handled by AdaControl.

Ex:
@example
adactl -d -f my_rules.aru proc.adb
@end example

In addition, output of the messages printed by the ``-d'' option can
be directed to a file (instead of being printed on the standard error
file). This is done by the ``-t'' option, which must be followed by
the file name.If the trace file exists, new messages are appended to
it.

@node Treatment of warnings, Exit on error, Verbose and debug mode, Command line options and parameters
@subsection Treatment of warnings
The ``-e'' option tells AdaControl to treat warnings as errors,
i.e. to report a return code of 1 even if only ``search'' rules were
triggered. @xref{Return codes}. It does not change the messages
however.

Conversely, the ``-E'' option tells AdaControl to @i{not} report
warnings at all, i.e. only errors are reported. However, if you ask
for statistics, the number of warning messages is still
counted. @xref{Rule types and report messages}.

@node Exit on error, Project files, Treatment of warnings, Command line options and parameters
@subsection Exit on error
If an internal error is encountered during the processing of a unit,
AdaControl will continue to process other units. However, if the
``-x'' option is given, AdaControl will stop on the first error
encountered. This option is mainly useful if you want to debug
AdaControl itself (or your own rules). @xref{In case of trouble}.

Ex:
@example
adactl -x -f my_rules.aru proc.adb
@end example

@node Project files, ASIS options, Exit on error, Command line options and parameters
@subsection Project files
@subsubsection Emacs style project files
An emacs project file (the file with a ``.adp'' extension used by the
Ada mode of Emacs) can be specified with the `` -p''
option. AdaControl will automatically consider all the directories
mentioned in ``src_dir'' lines from the project file.

Ex:
@example
adactl -f my_rules.aru -p proj.adp proc.adb
@end example

@subsubsection GPS project files
When run from GPS, AdaControl will automatically use the source
directories from the current (root) project. However, if you run it
from the command line, it will not accept ``.gpr'' project files,
because ASIS does not currently accept the ``-P'' option like other
Gnat commands do. Should this change in the future, a ``-P'' option
could be passed as described for the ``-I'' option. @xref{ASIS
options}.

In the mean time, you can generate a ``.adp'' project file from a
``.gpr'' project file from within GPS, by using the
``Tools/AdaControl/Generate .adp project'' menu. @xref{Running
AdaControl from GPS}. Alternatively, it is also possible to use GPS
project files by generating the tree files manually. @pxref{Generating
tree files manually} for details.

@node ASIS options,  , Project files, Command line options and parameters
@subsection ASIS options
Everything that appears on the command line after ``-@w{}-'' will be
treated as an ASIS option, as described in the ASIS user manual.

Casual users don't need to care about ASIS options, except in one
case: if you are running AdaControl from the command line (not from
GPS), and if the units that you are processing reference other units
whose source is not in the same directory, AdaControl needs to know
how to access these units (as GNAT would). This can be done either
by using an Emacs project file (the ``-p'' option), by passing a ``-I''
option to ASIS, or by putting the appropriate directories into the
ADA_INCLUDE_PATH environment variable.

It is possible to include one or several ``-I'' options to reference
other directories where sources can be found. The syntax is the same
as the ``-I'' option for GNAT.

Other ASIS options, like the ``-Cx'' and/or ``-Fx'' options, can be
specified. Most users can ignore this feature; however, specifying
these options can improve the processing time of big
projects. @xref{Optimizing  AdaControl}.

@node Return codes, Disabling rules, Command line options and parameters, Program Usage
@section Return codes
In order to ease the automation of rules checking with shell scripts,
AdaControl returns various error codes depending on how successful it
was. Values returned are:
@itemize
@item
0: At most ``search'' rules were triggered (no rule at all with ``-e''
option)
@item
1: At least one ``check'' rule was triggered (or at least one
``search'' or ``check'' rule with ``-e'' option)
@item
2: AdaControl was not run due to a syntax error in the rules or in the
specification of units.
@item
10: There was an internal failure of AdaControl.
@end itemize

@node Disabling rules, Helpful utilities, Return codes, Program Usage
@section Disabling rules
It is possible to disable rules on parts of the source
code by placing a tag (special Ada comment) in the source code. This
can be done in two ways: block disabling or line disabling. The
disabling tag is ``-@w{}-##''. Both ways take a list of rules to disable
as parameters. A list of rules is a list of rule names or
rule labels, separated by spaces. Alternatively, the list of rules can
be the word ``all'' to disable all rules.

In a ``--##'' line, everything appearing after a second occurrence of
``##'' is ignored. This allows the insertion of a comment explaining
why the rule is disabled at that point.

@subsection Block disabling
A rule is disabled from the ``rule off'' tag until the ``rule on''
tag. If there is no ``rule on'' tag, the rule is disabled up to the
end of file.

Syntax:
@example
--## rule off <rule_list>
Ada code block
--## rule on <rule_list>
@end example

Ex:
@example
--## rule off rule1 rule2
I := I + 1;
Proc (I);
--## rule on rule2
@end example

@subsection Line disabling
The rule is disabled only for the line where the tag appears.

Syntax:
@example
Ada code line --## rule line off <rule_list>
@end example
Ex:
@example
I := I + 1; --## rule line off rule3 rule_label_1
@end example
Conversely, it is possible to re-enable a rule for just the current
line in a block where rules are disabled:

Syntax:
@example
Ada code line --## rule line on <rule_list>
@end example
Ex:
@example
I := I + 1; --## rule line on rule3
@end example

@node Helpful utilities, Optimizing  AdaControl, Disabling rules, Program Usage
@section Helpful utilities
This section describe utilities that are handy to use in conjunction
with AdaControl.

@menu
* pfni::                        
* Adactl -D::                   
* makepat.sed::                 
* unrepr.sed::                  
@end menu

@node pfni, Adactl -D, Helpful utilities, Helpful utilities
@subsection pfni
The convention used to refer to entities (as described in
@ref{Specifying an Ada entity name}) is very powerful, but it may be
difficult to spell out correctly the name of some entities, especially
when using the overloaded syntax.

@code{pfni} (which stands for @i{Print Full Name Image}) can be used
to get the correct spelling for any Ada entity. The syntax of
@code{pfni} is:
@example
pfni [-sofdq] [-p <project-file>] <unit>[:<span>]
     [-- <ASIS options>]
<span> ::=   <line_number>
           | [<first_line>]-[<last_line>]
           | <line_number>:<column_number>
@end example
or
@example
pfni -h
@end example
If called with the ``-h'' option, @code{pfni} prints a help message
and exits.

Otherwise, @code{pfni} prints the full name image of all identifiers
declared in the indicated unit, unless there is a ``-f'' (full)
option, in which case it prints the full name image of all identifiers
(i.e. including those that are used, but not declared, in the
unit). The image is printed without overloading information, unless
the ``-o'' option is given.

The <unit> is given either as an Ada unit, or as a file name, provided
the extension is ``.ads'' or ``.adb'' (as in AdaControl). If a span is
given, only identifiers within the span are printed. In the first
form, the span includes only the indicated line; in the second form,
the span includes all lines from <first_line> to <last_line> (if
omitted, they are taken as the first and last line of the file,
respectively). In the third form, the span includes only the place at
the specified <line_number> and <column_number>.

Normally, the source line corresponding to the names is printed above
the names. The ``-q'' (quiet) option suppresses this.

If the ``-s'' option is given (or the unit is a file name with a
``.ads'' extension), the specification of the unit is processed,
otherwise the body is processed. The ``-p'' option specifies the name
of an Emacs project file, and the ``-d'' option is the debug mode, as
for AdaControl itself. ASIS options can be passed, like for
AdaControl, after a ``-@w{}-'' (but -FS is the default). @xref{ASIS
options}.

As a side usage of @code{pfni}, if you are calling a subprogram that
has several overloadings and you are not sure which one is called, use
@code{pfni} with the ``-o'' option on that line: the program will tell
you the full name and profile of the called subprogram.

@node Adactl -D, makepat.sed, pfni, Helpful utilities
@subsection Adactl -D
When run with the ``-D'' option, AdaControl simply outputs the list of
units that would be processed.

This list can be directed to a file with the ``-o'' option (if the
file exists, it won't be overwritten unless the ``-w'' option is
specified).  This file can then be used in an indirect list of
units. @xref{Input units}. Note that if you use the recursive (``-r'')
option, it is more efficient to create the list of units once and then
use the indirect file than to specify all applicable units each
time AdaControl is run.

@node makepat.sed, unrepr.sed, Adactl -D, Helpful utilities
@subsection makepat.sed
This file (provided in the ``src'' directory) is a sed script that
transforms a text file into a set of correponding regular expressions.
It is useful to generate model header files. @xref{Header_Comments}.

@node unrepr.sed,  , makepat.sed, Helpful utilities
@subsection unrepr.sed
This file (provided in the ``src'' directory) is a sed script that
comments out all representation clauses. It is typically useful if you
use a different compiler that accepts representation clauses not
supported by GNAT.

Typically, you would copy all your sources in a different directory,
copy ``unrepr.sed'' in that directory, then run:
@example
sed -i -f unrepr.sed *.ads *.adb
@end example
You can now run AdaControl on the patched files. Of course, you won't
be able to check rules related to representation clauses any more...

Note that the script adds ``-@w{}-UNREPR '' to all representation
clauses. Its effect can thus easily be undone with the following
commad:
@example
sed -i -e "s/--UNREPR //" *.ads *.adb
@end example

@node Optimizing  AdaControl, In case of trouble, Helpful utilities, Program Usage
@section Optimizing  AdaControl
There are many factors that may influence dramatically the speed of
AdaControl when processing many units. For example, on our canonical
test (same rules, same units), the extreme points for execution time
were 111s. vs 13s.! Unfortunately, this seems to depend on a number of
parameters that are beyond AdaControl's control, like the relative
speed of the CPU to the speed of the hard-disk, or the caching
strategy of the file system.

This section will give some hints that may help you increase the speed
of AdaControl, but it will not change the output of the program; you
don't really need to read it if you just use AdaControl
occasionnally. This section is concerned only with the GNAT
implementation of ASIS; other implementations work differently.

Bear in mind that the best strategy depends heavily on how your
program is organized, and on the particular OS and hardware you are
using. Therefore, no general rule can be given, you'll have to
experiment yourself. Hint: if you specify the ``-v'' option to
AdaControl, it will print in the end the elapsed time for running the
tests; this is very helpful to make timing comparisons.

Note: all options described in this section are ASIS options,
i.e. they must appear last on the command line, after a ``-@w{}-''.

@menu
* Tree files and the ASIS context::  
* Generating tree files manually::  
* Choosing an appropriate combination of options::  
@end menu

@node Tree files and the ASIS context, Generating tree files manually, Optimizing  AdaControl, Optimizing  AdaControl
@subsection Tree files and the ASIS context
Since AdaControl is an ASIS application, it is useful to explain here
how ASIS works. ASIS (and therefore AdaControl) works on a set of
units constituting a ``context''. Any reference to an Ada entity which
is not in the context (nor automatically added, see below) will be
ignored; especially, if you specify to AdaControl the name of a unit
which is not included in the current context, the unit will simply not
be processed.

ASIS works by exploring tree files (same name as the corresponding Ada
unit, with a ``.adt'' extension), which are ``predigested'' views of
the corresponding Ada units. By default, the tree files are generated
automatically when needed, and kept after each run, so that subsequent
runs do not have to recreate them.

A context in ASIS-for-Gnat is a set of tree files. Which trees are
part of the context is defined by the ``-C'' option:
@itemize
@item
-C1 Only one tree makes up the context. The name of the tree file must
follow the option.
@item
-CN Several explicit trees make up the context. The name of the tree
files must follow the option.
@item
-CA All available trees make up the context. These are the tree files
found in the current directory, and in any directory given with a
``-T'' option (which works like the ``-I'' option, but for tree files
instead of source files).
@end itemize

The ``-F'' option specifies what to do if the program tries to access
an Ada unit which is not part of the context:
@itemize
@item
-FT Only consider tree files, do not attempt to compile units
on-the-fly
@item
-FS Always compile units on-the-fly, ignore existing tree files
@item
-FM Compile on-the-fly units for which there is no already existing
tree file
@end itemize
Note that ``-FT'' is the only allowed mode, and @i{must} be specified,
with the ``-C1'' and ``-CN'' options.

The default combination used by AdaControl is ``-CA -FM''.

@node Generating tree files manually, Choosing an appropriate combination of options, Tree files and the ASIS context, Optimizing  AdaControl
@subsection Generating tree files manually
It is also possible to generate the tree files manually before running
AdaControl. Although this mode of operation is less practical, it is
recommended by AdaCore for any ASIS tool that deals with many
compilation units.  Some reasons why you might want to generate the
tree files manually are:
@itemize @bullet
@item
Your project uses GNAT project files;
@item
Your project has several source directories (ASIS had problems with
ADA_INCLUDE_PATH, until releases dated later than Sept. 1st,
2006). Note that an alternative solution is to specify source
directories with the -I option;
@item
It is faster to generate tree files once than to use ``compile on the
fly'' mode.
@end itemize

To generate tree files manually, simply recompile your project with
the ``-gnatct'' option.  This option can be passed to @code{gnatmake}
normally. Of course, you will need all other options needed by your
project (like the ``-P'' option if you are using GNAT project files).

Tree files may be copied into a different directory if you don't want
your current directory to be cluttered by them. In this case, use the
``-T'' ASIS option to indicate the directory where the tree files are
located.

If you chose to generate the tree files manually, you may want to
specify the ``-FT'' ASIS option (see above) to prevent from accidental
automatic recompilation.

@node Choosing an appropriate combination of options,  , Generating tree files manually, Optimizing  AdaControl
@subsection Choosing an appropriate combination of options
In order to optimize the use of AdaControl, it is important to remember
that reading tree files is a time-consuming operation. On the other
hand, a single tree file contains not only information for the
corresponding unit, but also for all units that the given unit depends
on. Moreover, our measures showed that reading an existing tree file
may be @i{slower} than compiling the corresponding unit on-the-fly
(but once again, YMMV).

Note also that the ``-r'' option (recursive mode) of AdaControl
implies an extra pass over the whole program tree to determine the
necessary units.

Here are some hints to help you find the most efficient combination of
options.
@itemize
@item
If you want to run AdaControl on all units of your program, use the
``-D'' option to create a file containing the list of all required
units, then use this file as an indirect file.
@item
Avoid having unnecessary tree files. All tree files in the context are
read by ASIS, even if they are not later used.  If you don't want to
run AdaControl on the whole project, deleting tree files from a
previous run can save a lot of time.
@item
When using an indirect file, the order in which units are given may
influence the speed of the program. As a rule of thumb, units that are
closely related should appear close to each other in the file. A good
starting point is to sort the file in alphabetical order: this way,
child units will appear immediately after their parent. You can then
reorder units, and measure if it has a significant effect on speed.
@item
If you want to check a unit individually, try using the ``-C1'' option
(especially if the current directory contains many tree files from
previous runs). Remember that you must specify the unit to check to
AdaControl, and the tree file to ASIS. I.e., if you want to check the
unit ``Example'', the command line should look like:
@example
adactl -f rules_file.aru example -- -FT -C1 example.adt
@end example
provided the tree file already exists.
@item
For each strategy, first run AdaControl with the default options
(which will create all necessary tree files). Compare execution time
with the one you get with ``-FT'' and ``-FS''. This will tell you if
compiling on-the-fly is more efficient than loading tree files, or not.
@end itemize

@node In case of trouble,  , Optimizing  AdaControl, Program Usage
@section In case of trouble
Like any sophisticated piece of software, AdaControl may fail when
encountering some special case of construct. ASIS may also fail
occasionnally; actually, we discovered several ASIS bugs during the
development of AdaControl. These were reported to ACT, and have been
corrected in the wavefront version of GNAT - but you may be using an
earlier version. In this case, try to upgrade to a newer version of
ASIS. If an AdaControl or ASIS problem is not yet solved, AdaControl
is designed in such a way that an occasionnal bug won't prevent you
from using it.

If AdaControl detects an unexpected exception during the processing of
a unit (an ASIS error or an internal error), it will abandon the unit,
clean up everything, and go on processing the remaining units. This
way, an error due to a special case in a unit will @i{not} affect the
processing of other units. AdaControl will return a Status of 10 in
this case.

However, if it is run with the ``-x'' option (eXit on error), it will
stop immediately, and no further processing will happen.

If you don't want the garbage from a failing rule to pollute your
report, you may chose to disable the rule for the unit that has a
problem. @xref{Inhibit command}.

If you encounter a problem while using AdaControl, you are very
welcome to report it to
@uref{mailto::rosen@@adalog.fr,,rosen@@adalog.fr}. Please include the
exact rule and the unit that caused the problem, as well as the
captured output of the program (with ``-d'' option).

@node Rules Usage, Examples of using AdaControl for common programming rules, Program Usage, Top
@chapter Rules Usage
This chapter describes each rule currently provided by
AdaControl. Note that the @code{rules} directory of the distribution
contains a file named @code{verif.aru} that contains an example of a
set of rules appropriate to check on almost any software.

A general limitation applies to all rules. AdaControl is a @i{static}
checking tool, and therefore cannot check usages that depend on
run-time values. For example, it is not possible to check rules
applying to an entity when this entity is aliased and accessed through
an access value, or rules applying to subprogram calls when the call
is a dispatching call.

@menu
* Abnormal_Function_Return::    
* Allocators::                  
* Array_Declarations::          
* Barrier_Expressions::         
* Case_Statement::              
* Characters::                  
* Declarations::                
* Default_Parameter::           
* Directly_Accessed_Globals::   
* Duplicate_Initialization_Calls::  
* Entities::                    
* Entity_Inside_Exception::     
* Exception_Propagation::       
* Expressions::                 
* Global_References::           
* Header_Comments::             
* Improper_Initialization::     
* Instantiations::              
* Insufficient_Parameters::     
* Local_Hiding::                
* Max_Blank_Lines::             
* Max_Call_Depth::              
* Max_Line_Length::             
* Max_Nesting::                 
* Max_Parameters::              
* Max_Size::                    
* Max_Statement_Nesting::       
* Movable_Accept_Statements::   
* Multiple_Assignments::        
* Naming_Convention::           
* No_Operator_Usage::           
* Non_Static::                  
* Not_Elaboration_Calls::       
* Not_Selected_Name::           
* Parameter_Aliasing::          
* Other_Dependencies::          
* Potentially_Blocking_Operations::  
* Pragmas::                     
* Reduceable_Scope::            
* Representation_Clauses::      
* Return_Type::                 
* Side_Effect_Parameters::      
* Silent_Exceptions::           
* Simplifiable_Expressions::    
* Simplifiable_Statements::     
* Special_Comments::            
* Statements::                  
* Style::                       
* Terminating_Tasks::           
* Uncheckable::                 
* Units::                       
* Unnecessary_Use_Clause::      
* Unsafe_Paired_Calls::         
* Unsafe_Unchecked_Conversion::  
* Usage::                       
* Use_Clauses::                 
* With_Clauses::                
@end menu

@node Abnormal_Function_Return, Allocators, Rules Usage, Rules Usage
@section Abnormal_Function_Return
@subsection Syntax
@example
<check|search|count> abnormal_function_return;
@end example
@subsection Action
This rule controls that the sequence of statements of each function
body, as well as  each exception handler, ends either with a
@code{@b{return}} statement or a @code{@b{raise}} statement (or
equivalently, a call to @code{Ada.Exceptions.Raise_Exception} or
@code{Ada.Exceptions.Reraise_Occurrence}). Note that this last
statement can be embedded in blocks (i.e., it can be followed by any
number of @code{@b{end}} for block statements, but nothing else).

This is a sufficient (but of course not necessary) condition to ensure
that no function raises @code{Program_Error} due to reaching the end
of its statements without encountering a @code{@b{return}}.

This rule can be specified only once.

Ex:
@example
check abnormal_function_return
@end example

@subsection Tip
This rule checks that a function always returns correctly, but does not
prevent multiple @code{@b{return}} statements in functions. If you want
to ensure that there is exactly one @code{@b{return}} statement in functions,
and that this statement is always the last one, use this rule together with
the rule @code{statements(function_return)}.
@xref{Statements}.

@node Allocators, Array_Declarations, Abnormal_Function_Return, Rules Usage
@section Allocators
@subsection Syntax
@example
<check|search|count> allocators
   [(task|protected|<type name> @{, task|protected|<type name>@})];
@end example

@subsection Action
This rule controls usage of allocators.  If type names are given, only
allocators whose allocated type is mentioned are controlled; if
``task'' or ``protected'' is given, allocators for task types or
protected types (respectively) are controlled; otherwise all
allocators are controlled. This rule is especially useful for finding
memory leaks, since it tells all the places where dynamic allocation
occurs.

Ex:
@example
search allocators (standard.string);
check allocators (T'Class);
@end example

@subsection Tips
The type given in the rule is the first named subtype, and the rule
will also find allocators that use a subtype of this type; especially,
if the allocated type is @code{T'Base}, it will be found as T.

The type mentionned in the rule is the one following the
@code{@b{new}} keyword, which is not necessarily the same as the
expected type in presence of implicit conversions like this:

@example
   @b{type} T @b{is} @b{tagged} ...;
   @b{type} Class_Access @b{is} @b{access} T'Class;
   X : Class_Access;
begin
   X := @b{new} T;
@end example

This allocator will be found for type @code{T}, not for type @code{T'Class}.

@node Array_Declarations, Barrier_Expressions, Allocators, Rules Usage
@section Array_Declarations
@subsection Syntax
@example
<check|search|count> Array_Declarations (First, <value>);
<check|search|count> Array_Declarations (Max_Length, <maximum_length>);
@end example
@subsection Action
This rule controls various properties of array types and array objects
declarations, depending on the keyword given as the first parameter:

@itemize
@item
``First'' controls the lower bound of each dimension of arrays (even
unconstrained array types) whose value is not the given value. If this
subrule is given both for ``search'' and for ``check'', the value for
``search'' is interpreted as the prefered one, and the value for
``check'' is interpreted as an alternative acceptable one; i.e., it is
a warning if the value is the one given for ``check'', and an error if
it is neither. In short:
@example
search array_declarations (first, 1);
check array_declarations (first, 0);
@end example
will issue a warning if the lower bound of an array is 0, and an error
if it is neither 0 or 1.
@item
``Max_Length'' controls arrays that have a dimension whose number of
elements is greater than the given value, except for unconstrained
array types.
@end itemize

This rule can be specified at most once for each subrule and for each
of ``check'', ``search'' and ``count''. It is thus possible for each
subrule to have a value considered a warning, and a value considered
an error.

Ex:
@example
check array_declarations (first, 1);
check array_declarations (max_length, 100);
@end example

@subsection Tip
The subrule @code{Max_Length} ignores index constraints that are not
static.  Non static index constraints can be controlled with the rule
@code{Non_Static (Index_Constraint)}. @xref{Non_Static}.
@node Barrier_Expressions, Case_Statement, Array_Declarations, Rules Usage
@section Barrier_Expressions
@subsection Syntax
@example
<check|search|count> Barrier_Expressions ([<allowable> @{, <allowable>@}]);
<allowable>    ::= <entity> | <keyword>
<keyword> ::= allocation          | any_component   | any_variable        |
              arithmetic_operator | array_aggregate | comparison_operator |
              conversion          | dereference     | indexing            |
              function_attribute  | local_function  | logical_operator    |
              record_aggregate    | value_attribute
@end example
@subsection Action
This rule controls expressions used in barriers of protected
entries. Without parameters, the only elements allowed in barriers are
references to boolean components of the protected element and
litterals (this corresponds to what is allowed for the Ravenscar
profile). Parameters specify other constructs that are allowed:
@itemize @bullet
@item
Any entity (like a global variable, a function...) can be specified
and is thus allowed.
@item
``allocation'' allows use of allocators.
@item
``any_component'' allows use of protected components that are not of
type @code{Standard.Boolean}.
@item
``any_variable'' allows use of any variable (i.e. variables external to
the protected element).
@item
``arithmetic_operator'' allows use of predefined arithmetic operators
(@code{"+"}, @code{"**"}, etc.).
@item
``array_aggregate'' allows use of array aggregates.
@item
``comparison_operator'' allows use of predefined comparison and
membship operators (@code{"="}, @code{">"}, @code{@b{in}}, etc.).
@item
``conversion'' allows use of type conversions and type qualifications.
@item
``dereference'' allows use of dereferencing of access types (both implicit
and explicit dereferences).
@item
``indexing'' allows use of array indexing and slices.
@item
``function_attribute'' allows use of attributes that are functions
(like @code{'Pred}, @code{'Image}, etc.).
@item
``local_function'' allows use of (protected) functions declared in the
same protected object.
@item
``logical_operator'' allows use of predefined logical operators and
short-circuit forms (@code{@b{and}}, @code{@b{or else}}, etc.).
@item
``record_aggregate'' allows use of record aggregates and extension
aggregates.
@item
``value_attribute'' allows use of attributes that are simple values
(like @code{'First}, @code{'Terminated}, etc.).
@end itemize

This rule can be given only once for each of ``check'', ``search'' and ``count''.

Ex:
@example
search barrier_expressions;
check  barrier_expressions (logical_operator, comparison_operator,
                            any_component,
                            Pack.Global_State);
@end example

@subsection Tips
The goal of the ``Simple_Barrier'' restriction from the Ravenscar
profile is to ensure that evaluation of barriers never raise
exceptions. Even simple things like a qualified expression can raise
exceptions, but in practice more than the restriction of the Ravenscar
profile can be ``reasonably'' allowed.

Note that the various ``operator'' keywords allow only the use of
predefined operators. If a user defined operator should be allowed,
provide it explicitely as an <entity>. There is no way to allow any
function call, since this would boil down to allowing pretty much
anything, but you can of course specify explicitely functions that can
be called.

You can provide this rule both for ``check'' and ``search'', but of
course it makes sense only if the set of allowed features for
``search'' is a subset of those allowed for ``check''.  This way, the
use of certain features can be interpreted only as a warning.

@node  Case_Statement, Characters, Barrier_Expressions, Rules Usage
@section Case_Statement
@subsection Syntax
@example
<check|search|count> Case_Statement (max_range_span, <maximum_span>);
<check|search|count> Case_Statement (max_values, <maximum_span>);
<check|search|count> Case_Statement (min_others_span, <minimum_span>);
<check|search|count> Case_Statement (min_paths, <minimum_span>);
@end example

@subsection Action
This rule controls various sizings in case statement, depending on the
keyword given as the first parameter:

@itemize
@item
``max_range_span'' controls that ranges used as choices in  @code{@b{case}}
statements cover at most the specified number of values. Especially, a
value of 0 disallows all ranges as choices.

@item
``max_values'' controls @code{@b{case}} statements where the subtype
of the case selector covers more values than the specified number of
values.

@item
``min_others_span'' controls @code{@b{when others}} case alternatives that
cover less than the specified number of values. The <minimum_span>
must be at least 1 (i.e., if 1 is specified, the rule will signal
``when others'' that cover no value at all).

@item
``min_paths'' controls @code{@b{case}} statements with less paths
(i.e. @code{@b{when}} branches) than the specified number of values.
@end itemize

This rule can be specified at most once for each subrule and for each
of ``check'', ``search'' and ``count''. It is thus possible for each
subrule to have a value considered a warning, and a value considered
an error.

Ex:
@example
check  Case_Statement (min_others_span, 1);
search Case_Statement (min_others_span, 5);

check  Case_Statement (max_values, 10);
check  Case_Statement (min_paths, 5);
@end example

@subsection Limitations
If some characteristic of the @code{@b{case}} statement depend on a
generic formal type, it is not possible to control some of the
features statically. Such cases are detected by the rule
``uncheckable''. @xref{Uncheckable}.

@node  Characters, Declarations, Case_Statement, Rules Usage
@section Characters
@subsection Syntax
@example
<check|search|count> characters [(<class_kw> @{, <class_kw>@})];
class_kw ::= control | not_iso_646 | trailing_space | wide
@end example

@subsection Action
This rule controls the occurrence in the source file of characters
belonging to the specified classe(s). Without parameters, all classes
are controlled.  The classes are defined as follows:
@itemize @bullet
@item
``control'': control characters that are allowed by the language
(ASCII HT,  ASCII VT and ASCII FF).
@item
``not_iso_646'': characters outside the ISO-646 set (aka ASCII).
@item
``trailing_space'': space characters appearing at the end of the
source line.
@item
``wide'': wide characters that are not in @code{Standard.Character}.
@end itemize

This rule can be given only once for each class of characters.

Ex:
@example
check characters (control, trailing_space);
search characters (not_iso_646);
@end example

@subsection Limitations
With the ``wide'' subrule, the error message may seem to not always
appear at the right place; this depends on the encoding scheme
used. For example, if your source contains (using bracket encoding):
@example
S : Wide_String := "["1041"]["1042"]";
@end example
it will appear to AdaControl as a string containing two characters,
and therefore the error message for the second wide character will
point at two characters after the opening quote of the string.

This rule controls only the characters in the source file; other means
of having characters in the corresponding classes (like using the
@code{'Val} attribute) are not controlled.

@node  Declarations, Default_Parameter, Characters, Rules Usage
@section Declarations
@subsection Syntax
@example
<check|search|count> declarations (<decl_spec> @{, <decl_spec>@});
decl_spec   ::= @{<location_kw>@} <declaration_kw>
location_kw ::= all    | block    | local | nested | own | private |
                public | task_body
declaration_kw ::=
   abstract_function               | abstract_procedure            |
   abstract_type                   | access_protected_type         |
   access_subprogram_type          | access_task_type              |
   access_type                     | aliased                       |
   array                           | array_type                    |
   character_literal               | child_unit                    |
   constant                        | constrained_array_type        |
   decimal_fixed_type              | defaulted_discriminant        |
   defaulted_generic_parameter     | defaulted_parameter           |
   derived_type                    | discriminant                  |
   enumeration_type                | entry                         |
   exception                       | extension                     |
   fixed_type                      | float_type                    |
   formal_function                 | formal_package                |
   formal_procedure                | function                      |
   function_instantiation          | generic                       |
   generic_function                | generic_package               |
   generic_procedure               | handlers                      |
   in_out_generic_parameter        | in_out_parameter              |
   instantiation                   | integer_type                  |
   initialized_protected_field     | initialized_record_field      |
   limited_private_type            | modular_type                  |
   multiple_names                  | named_number                  |
   non_limited_private_type        | non_identical_renaming        |
   non_identical_operator_renaming | not_operator_renaming         |
   null_extension                  | null_ordinary_record_type     |
   null_procedure                  | null_tagged_type              |
   operator                        | operator_renaming             |
   ordinary_fixed_type             | ordinary_record_type          |
   out_parameter                   | package                       |
   package_instantiation           | procedure_instantiation       |
   package_statements              | predefined_operator           |
   private_extension               | procedure                     |
   protected                       | protected_entry               |
   protected_type                  | record_type                   |
   renaming                        | separate                      |
   signed_type                     | single_array                  |
   single_protected                | single_task                   |
   subtype                         | tagged_type                   |
   task                            | task_entry                    |
   task_type                       | type                          |
   unconstrained_array_type        | uninitialized_protected_field |
   uninitialized_record_field      | uninitialized_variable        |
   variable                        | variant_part
@end example

@subsection Action
This rule controls usage of certain Ada declarations, possibly only
those occurring at specified locations.

The <location_kw> restricts the places where the occurrence of the
declaration is controlled.  Several <location_kw> can be given, in
which case the declaration is controlled at places where all the
keywords apply. If there is no <location_kw>, it is assumed to be
``all''.
@itemize @bullet
@item
@code{all}: puts no special restriction to the location. This keyword
can be specified for readability purposes, and if specified must
appear alone (not with other <location_kw>).
@item
@code{block}: only declarations appearing in block statements are controlled.
@item
@code{local}: only local declarations are controlled (i.e. only declarations
appearing in (generic) packages, possibly nested, are allowed).
@item
@code{nested}: only declarations nested in another declaration are
controlled (i.e. only library level declarations are allowed).
@item
@code{own}: only declarations that are local to a (generic) package body
are controlled.
@item
@code{public}: only declarations appearing in the visible part of
(generic) packages are controlled.
@item
@code{private}: only declarations appearing directly in a private
part are controlled.
@item
@code{task_body}: only declarations appearing directly in a task body
are controlled. Note that it would not make sense to have a
<location_kw> for task @i{specifications}, since only entries can
appear there, and they cannot appear anywhere else.
@end itemize

The <declaration_kw> specifies what kind of declaration to control:
@itemize @bullet
@item
Declaration keywords that are Ada keywords match the corresponding Ada
declarations.
@item
@code{abstract_function} and @code{abstract_procedure} control the
declarations of abstract functions and abstract procedures,
respectively.
@item
@code{abstract_type} controls the declaration of non-formal abstract
types.
@item
@code{access_type} controls all access type declarations, while
@code{access_subprogram_type}, @code{access_protected_type}, and
@code{access_task_type} control only access to procedures or functions,
access to protected types, or access to task types, respectively.
@item
@code{array} controls all array definitions (array types and single
arrays), while @code{array_type} controls only array types and
@code{single_array} controls only single arrays (objects of an
anonymous array type. @code{constrained_array_type} controls only
constrained array types, while @code{unconstrained_array_type}
controls only unconstrained array types.
@item
@code{character_literal} controls the declaration of new character
literals, i.e. character literals defined as part of the values of an
enumeration type.
@item
@code{child_unit} controls the declaration of all child units.
@item
@code{defaulted_parameter} controls subprogram or entry (@b{in})
parameters that provide a default value, while
@code{defaulted_generic_parameter} controls generic formal objects
that provide a default value.
@item
@code{derived_type} controls regular derived types, but not type
extensions (derivations of tagged types). These are controlled by
@code{extension} and @code{private_extension}.
@item
@code{discriminant} controls all declarations of types with
discriminants, while @code{defaulted_discriminants} controls only
those where defaults are provided for the discriminants.
@item
@code{enumeration_type} controls the declaration of enumeration types.
@item
@code{exception} controls exception declarations.
@item
@code{fixed_type} controls all declarations of fixed point types while
@code{ordinary_fixed_type} controls only ordinary (binary) fixed point
types, and @code{decimal_fixed_type} controls only decimal fixed point
types.
@item
@code{float_type} controls declarations of floating point types.
@item
@code{formal_function}, @code{formal_package}, and
@code{formal_procedure} control generic formal functions, packages,
and procedures, respectively.
@item
@code{instantiation} controls all instantiations, while
@code{function_instantiation}, @code{package_instantiation},
@code{procedure_instantiation} control function (respectively package,
procedure) instantiations.
@item
@code{generic_function}, @code{generic_package},
@code{generic_procedure} control generic function (respectively
package, procedure) declarations.
@item
@code{handlers} controls the presence of exception handlers in any
handled sequence of statements.
@item
@code{in_out_parameter} and @code{out_parameter} control subprogram
and entry parameters of modes @code{@b{in}} @code{@b{out}} and
@code{@b{out}} (respectively), while @code{in_out_generic_parameter}
and @code{out_generic_parameter} do the same for @i{generic} formal
parameters
@item
@code{integer_type} controls all declarations of integer types, while
@code{signed_type} controls only signed integer types, and
@code{modular_type} controls only modular types.
@item
@code{initialized_record_field} and @code{initialized_protected_field}
control the declaration of record (respectively protected) component
that include a default initialization, while
@code{uninitialized_record_field} and
@code{uninitialized_protected_field} control the declaration of record
(respectively protected) component that do not include a default
initialization
@item
@code{limited_private_type} controls limited private type
declarations, while @code{non_limited_private_type} controls regular
(non limited) private type declarations.
@item
@code{multiple_names} controls declarations where more than one
defining identifier is given in the same declaration.
@item
@code{named_number} controls declarations of named numbers,
i.e. untyped constants.
@item
@code{null_extension} controls record extensions (derived tagged
types) that contain no new elements.  Similarly,
@code{null_ordinary_record_type} and @code{null_tagged_type} control
ordinary records and tagged types that contain no elements. Note that
the record definitions may be plain ``@code{@b{null}}
@code{@b{record}}'' definitions, or full record definitions that
contain only null components. However, a definition is not considered
null if it contains a variant part.
@item
@code{null_procedure} controls procedure declarations whose sequence of
statements contain only @code{@b{null}} statements.
@item
@code{operator} controls the definition of operators (things like
@code{"+"}); note that the message is given on the specification if
there is an explicit specification, on the body
otherwise. @code{predefined_operator} controls only operator
definitions that overload a predefined operator (like @code{"+"} on a
numeric type, for example).
@item
@code{package_statements} controls the presence of elaboration
statements in the bodies of packages (or generic packages).
@item
@code{private_extension} controls private extensions, i.e. derivations
from a tagged type with a @code{@b{with private}} extension part.
@item
@code{record_type} controls all record type declarations (tagged or
not), while @code{ordinary_record_type} controls only non-tagged
record types, and @code{tagged_type} controls only tagged record types.
@item
@code{renaming} controls all renaming declarations, while
@code{operator_renaming} controls only those that are renamings of an
operator, @code{not_operator_renaming} controls only those that are
not renamings of an operator, @code{non_identical_renaming} controls
only those where the new name and the old name are not the same, and
@code{non_identical_operator_renaming} does the same, but only for
renamings of operators.
@item
@code{subtype} control all explicit subtype declarations (i.e. not all
anonymous subtypes that appear at various places in the  language).
@item
@code{task} controls task type declarations as well as single tasks
declarations while @code{single_task} and @code{task_type} control
only single task declarations or task type declarations respectively
(and similarly for @code{protected}).
@item
@code{type} controls all type (but not subtype) declarations.
@item
@code{variable} controls all variable declarations, while
@code{uninitialized_variable} controls only variable declarations that
do not include an initialization expression.
@item
@code{variant_part} controls variant parts in record defintions.
@end itemize

Ex:
@example
search declarations (task, exception);
check declarations (block procedure, block function, block package);
check declarations (visible task);
@end example

@subsection Tips
Certain keywords are @i{not} exclusive, and it may be the case that
several keywords apply to the same declaration; in this case, they are
all reported.  For example, if you specify:
@example
check declarations (record_type, tagged_type);
@end example
tagged
types will be reported both as ``record_type'' and ``tagged_type''.

Some of the keyword do not seem very useful; it would be strange to
have a programming rule that prevents all type declarations... But
bear in mind that the <location_kw> can be used to restrict the check
to certain locations; moreover, AdaControl can be used not only for
checking, but also for searching; finding all type declarations in a
set of units can make sense. As another example, ``search declarations
(own variable);'' will find all variables declared directly in package
bodies.

Some modifiers do not make sense with certain declarations; for
example,  a ``private out_parameter'' is impossible (a parameter
occurs in a subprogram declaration, not @i{directly} in a private
part). This is not a problem as far as the rule is concerned, but
don't expect to find any...

@node Default_Parameter, Directly_Accessed_Globals, Declarations, Rules Usage
@section Default_Parameter
@subsection Syntax
@example
<check|search|count> default_parameter
   (<entity> | all, <formal name> | all, [not] used);
@end example

@subsection Action
This rule controls subprogram calls or generic instantiations that use
(or conversely don't use) the default value for the indicated
parameter. If a subprogram is called, or a generic instantiated, whose
name matches <entity>, and it has a formal whose name is <formal
name>, then:
@itemize @bullet
@item
If the string @code{used} (case irrelevant) is given as the third
parameter, the rule reports when there is no corresponding actual
parameter (i.e. the default value is used for the parameter).
@item
If the string @code{not used} (case irrelevant) is given as the third
parameter, the rule reports when there is an explicit corresponding
actual parameter (i.e. the default is not used for the parameter).
@item
If the string given as the third parameter is anything else, it is an
error.
@end itemize

Alternatively, the <entity> and/or the <formal name> can be replaced by
the keyword @code{all}, in which case any entity (respectively formal) will
match.

Ex:
@example
check default_parameter (P, X, used);
check default_parameter (P, Y, not used);
search default_parameter (all, all, used);
@end example

@subsection Tip
If the <entity> is a generic subprogram, it is also possible to give a
formal parameter  (a parameter of the subprogram, not a generic
parameter) as the <formal name>; in this case, all instantiations of
the indicated generic subprogram will be controlled for the use of the
indicated parameter.

@node Directly_Accessed_Globals, Duplicate_Initialization_Calls, Default_Parameter, Rules Usage
@section Directly_Accessed_Globals
@subsection Syntax
@example
<check|search|count> Directly_Accessed_Globals [(<kind_kw> @{,<kind_kw>@})];
kind_kw ::= plain | accept | protected
@end example
@subsection Action
This rule controls global variables declared directly in (generic)
package bodies that are accessed outside of dedicated callable
entities (i.e. procedure or function, possibly protected, protected
entries, and @code{@b{accept}} statements).

This rule can be specified only once.  The parameters indicate which
kinds of callable entity are allowed: ``plain'' for non-protected
subprograms, ``protected'' for protected subprograms, and ``accept''
for @code{@b{accept}} statements). Without parameters, all forms are
allowed.

More precisely, this rule ensures that the global variables are read
from a single callable entity, and  written by a single callable
entity. Note that the same callable entity can read and write a
variable, but in this case no other callable entity is allowed to read
or write the variable.
@itemize @bullet
@item
Subprograms used to read/write the variables must be declared at the
same level as the variable itself (i.e. not nested), and must not be
generic.
@item
Protected subprograms used to read/write the variables must both be
part of the same single protected object, which must be declared at
the same level as the variable itself (i.e. not nested); they are not
allowed to be declared in a protected @i{type}, since if there are
several protected objects of the same type, mutual exclusion would not
be enforced.
@item
@code{@b{accept}} statements used to read/write the variables must
both be part of the same single task object, which must be declared at
the same level as the variable itself (i.e. not nested); they are not
allowed to be declared in a task @i{type}, since if there are several
task objects of the same type, mutual exclusion would not be enforced.
@end itemize
In short, this rule enforces that all global variables are accessed by
dedicated access subprograms, and that only those subprograms access
the variables directly. If given with the keyword ``protected'' and/or
``accept'', it enforces that global variables are accessed only by
dedicated protected subprograms or tasks, ensuring that no race condition is
possible.

Ex:
@example
check directly_accessed_globals
@end example

@subsection Tips
Note that this rule controls global variables from package @i{bodies},
not those from the specification. This is intended, since it makes
little sense to declare a variable in a specification, and then
require it not to be accessed directly, but through provided
subprograms.  Obviously, in this case the variable should be moved to
the body.

Note that AdaControl can check that no variable is declared in a
package specification with the following rule:
@example
check usage (variable, from_spec);
@end example
@pxref{Usage} for details.

@subsection Limitations
AdaControl cannot check entities accessed through dynamic names
(dynamic renaming, access on aliased variables).  Use of such
constructs is detected by the rule ``uncheckable''.
@xref{Uncheckable}.

@node Duplicate_Initialization_Calls, Entities, Directly_Accessed_Globals, Rules Usage
@section Duplicate_Initialization_Calls
@subsection Syntax
@example
<check|search|count> duplicate_initialization_calls
   (<procedure> @{, <procedure>@});
@end example
@subsection Action
This rule controls calls to initialization procedures that are
duplicated. The initialization procedures to be controlled are passed
as parameters to the rule.

More precisely, the initialization procedures must follow one of these
patterns:
@itemize @bullet
@item
The procedure only has @code{@b{in}} parameters. All actual parameters
used in calls are static, and not two calls have the same values for
all parameters.
@item
The procedure has exactly one @code{@b{out}} parameter (and no
@code{@b{in out}} parameter). Not two calls refer the same actual variable
for the @code{@b{out}} parameter.
@end itemize

The rule controls any violation of these patterns. If a procedure passed as parameter
does not have a profile that corresponds to one of the above patterns, it is an error.

Ex:
@example
check duplicate_initialization_calls (pack.init_proc);
@end example

@subsection Limitation
If a variable passed as an @code{@b{out}} parameter is not statically
determinable, it is not controlled by the rule. Such a case is
detected by the rule ``uncheckable''.  @xref{Uncheckable}.

@node Entities, Entity_Inside_Exception, Duplicate_Initialization_Calls, Rules Usage
@section Entities
@subsection Syntax
@example
<check|search|count> entities (<name> @{, <name>@});
@end example

@subsection Action
This rule controls all uses of the indicated entities. It is not
intended to replace cross-references, but can be quite handy to check,
for example, that a program does not contain any more calls to
debugging procedures before fielding it.

Note that this rules reports on the use of the @i{entity}, not the
@i{name}: if an entity has been renamed, it will be found under its
various names.  Similarly, if the given entity is a generic unit or an
entity declared inside a generic unit, all corresponding uses in all
instances will be reported.

Ex:
@example
search entities (Debug.Trace);
check  entities (Ada.Text_IO.Float_IO.Put);
@end example
The second line will report on any use of a @code{Put} from any
instantiation of @code{Float_IO}.

@subsection Tips
This rule can also be used to check for all occurrences of certain
attributes with the ``@code{all <Attribute>}'' syntax. For example,
the following will report on any usage of @code{'Unchecked_Access}:
@example
check entities (all 'Unchecked_Access);
@end example

In certain contexts, only a limited set of the Ada predefined units is
allowed. For example, it can be useful to forbid entities from
@code{Standard}, @code{System}, or entities defined in special needs
annexes. The @code{rules} directory of Adacontrol contains files with
Entity rules that forbid the use of various predefined Ada
units. Comment out the lines for the units that you want to allow.
You can then simply ``source'' these files from your own rule file (or
copy the content) if you want to disallow these units. @xref{Rules
files provided with AdaControl}.

@subsection Limitation
Gnat defines @code{Unchecked_Conversion} and
@code{Unchecked_Deallocation} as separate entities, rather than
renamings of @code{Ada.Unchecked_Conversion} and
@code{Ada.Unchecked_Deallocation}. As a consequence, it is necessary
to specify explicitely both forms if you want to make sure that the
corresponding generics are not used.

@node Entity_Inside_Exception, Exception_Propagation, Entities, Rules Usage
@section Entity_Inside_Exception
@subsection Syntax
@example
<check|search|count> entity_inside_exception (<spec> @{, <spec>@});
<spec> ::= [not] <entity> | calls
@end example

@subsection Action
This rule controls exception handlers that contain references to one
or several Ada entities specified as parameters. If the keyword
``calls'' is given, it stands for all subprogram and entry calls. If
an <entity> (or ``calls'') is preceded by the keyword ``not'', it is
not included in the list of controlled entities (i.e.  the entity is
allowed in the exception handler). This allows to make exceptions to a
more general specification of an entity, or to allow calls to
well-defined procedures if the keyword ``calls'' is given.

Ex:
@example
check entity_inside_exception (ada.text_io.put_line);

-- Control all calls, except to the Report_Exception procedure:
check entity_inside_exception (calls, not Reports.Report_Exception);

-- Control all Put, except the one on Strings:
check entity_inside_exception (all Put,
                               not Ada.Text_IO.Put@{Standard.String@});
@end example

@node Exception_Propagation, Expressions, Entity_Inside_Exception, Rules Usage
@section Exception_Propagation
@subsection Syntax
@example
<check|search|count> exception_propagation
   ([<level>,] interface, <convention> @{, <convention> @});
<check|search|count> exception_propagation
   ([<level>,] parameter, <parameter name> @{, <parameter name>@});
<check|search|count> exception_propagation
   ([<level>,] task);
<check|search|count> exception_propagation
   (<level>, declaration);
@end example

@subsection Action
This rule controls subprograms, tasks, or all declarations that can
propagate exceptions, while being used in contexts where it is
desirable to ensure that no exception can be propagated.

A subprogram or task is considered as not propagating if:
@enumerate
@item
it has an exception handlers with a ``@code{@b{when others}}'' choice
@item
no exception handler contains a @code{@b{raise}} statement, nor any
call to @code{Ada.Exception.Raise_Exception} or
@code{Ada.Exception.Reraise_Occurrence}.
@end enumerate

A declaration is considered propagating if it includes elements that
could propagate exceptions. The strength of the check depends on the
given <level>.  The possible values and their effect are:
@itemize @bullet
@item
0: expressions in declarative parts are not considered (anything
allowed, default behaviour for ``interface'', ``parameter'' and
``task''. Not allowed for ``declaration'').
@item
1: no function calls (including operators) are allowed in expressions.
@item
2: same as 1, plus no use of variables in expressions allowed.
@item
3: same as 2, plus no declaration of objects (constants or variables)
allowed (not very useful for ``declaration'').
@end itemize

It is dangerous to call an Ada subprogram that can propagate
exceptions from a language that has no exception (and especially
C). Therefore any such subprogram should have a ``catch-all''
exception handler. In its first form, the rule analyzes all
subprograms to which an @code{Interface} or @code{Export} pragma
applies (with the given convention(s)), and reports on those that can
propagate exceptions.

Moreover, many systems (typically windowing systems) use call-back
subprograms. Although the native interface is generally hidden behind
an Ada binding, the call-back subprograms will eventually be called
from another language. In its second form, the rule is given one or
more fully qualified formal parameter names (i.e. in the form of the
parameter name prefixed by the full name of its subprogram, see
@ref{Specifying an Ada entity name}). The rule will report on any
subprogram that can propagate exceptions and is used as the prefix of
a @code{'Access} or @code{'Address} attribute that appears as part of
an actual value for the indicated formal. Similarly, the indicated
formal can also be the name of a formal procedure or function of a
generic. In this case, the rule will report on any subprogram that can
propagate exceptions and is used as an actual in an instantiation for
the given formal.

Since tasks die silently if an exception is propagated out of
their body, it is generally desirable to ensure that every task has an
exception handler that (at least) reports that the task is being
completed due to an exception. In its third form, the rule will report
on any task that can propagate exceptions.

For these three forms, ensuring that a handler is present protects
against exceptions raised in the sequence of statements, but not
against exceptions raised by declarations. In addition, the (optional)
@code{<level>} parameter can be used to control the use of certain
constructs in the declarative part of subprograms or tasks, in order
to minimize the possibility of exceptions being raised.

Finally, it is sometimes desirable to make sure that no declaration
raises an exception, ever. In its fourth form, the rule will report on
any declaration that can propagate exceptions, irrespectively of where
it appears.  In this case, the specification of <level> is required
and cannot be 0.

Ex:
@example
check exception_propagation (interface, C);
check exception_propagation (parameter, Pack.Register.CB);
check exception_propagation (task);
check exception_propagation (2, declaration);
@end example

The first line will report on any subprogram to which a
@code{@b{pragma} Interface (C,...)} applies that can propagate
exceptions.

If @code{Proc} is a procedure that can propagate exceptions, the
second line will report on every call like:
@example
Pack.Register (CB => Proc'Access);
@end example

The third line will report on any task that can terminate silently due
to an unhandled exception.

The fourth line will report on any declaration that makes use of
function calls or variables.

@subsection Tips
Note that the registration procedure can be designated by an access
type, but in this case, use the name of the formal for the access
type. For example, given:
@example
@b{package} Pack @b{is}
   @b{type} Acc_Proc @b{is} @b{access} @b{procedure};
   @b{type} Acc_Reg @b{is} @b{access} @b{procedure} (CB : Acc_Proc);
   ...
   Ptr : Acc_Reg := ...;
@end example

You can give a rule such as:
@example
check exception_propagation (parameter, Pack.Acc_Reg.CB);
@end example
All procedures registered by a call to @code{Pack.Ptr.@b{all}} will be considered.

@subsection Limitations
An exception may be raised in a subprogram considered as not
propagating by this rule, if an exception handler calls a subprogram
that propagates an exception.

The rule will not consider subprograms that are not statically known
(i.e. if a subprogram is registered through a dereference of a pointer
to subprogram), like in the following example:
@example
Pack.Register (CB => Pointer.@b{all}'Access);
@end example

Due to a weakness of the ASIS standard, references to subprograms that
appear in dispatching calls are not considered. This limitation will
be removed as soon as we find a way to work around this problem, but
the issue is quite difficult!

These last two cases are detected by the rule
``uncheckable''. @xref{Uncheckable}.

@node Expressions, Global_References, Exception_Propagation, Rules Usage
@section Expressions
@subsection Syntax
@example
<check|search|count> expressions (<expression_kw> @{, <expression_kw>@});

expression_kw ::=
   and                   | and_then                         |
   array_aggregate       | array_others                     |
   complex_parameter     | inconsistent_attribute_dimension |
   mixed_operators       | or                               |
   or_else               | real_equality                    |
   record_aggregate      | record_others                    |
   slice                 | unqualified_aggregate            |
   xor

@end example
@subsection Action
This rule controls usage of certain forms of expressions. The rule can
be specified at most once for each expression keyword.
@itemize @bullet
@item
@code{and}, @code{or}, @code{xor}, @code{and_then}, and @code{or_else}
control usage of the corresponding logical operator (or short circuit
form).
@item
@code{array_aggregate} and @code{record_aggregate} control array and
record aggregates, respectively, while @code{unqualified_aggregate}
controls aggregates (both arrays and records) that do not appear
directly within a qualified expression
@item
@code{array_others} and @code{record_others} control the occurrence of
a @code{@b{when others} =>} association in array and record
aggregates, respectively.
@item
@code{complex_parameter} controls complex expressions used as actual
parameters in subprogram (or entry) calls. A complex expression is any
expression that includes a function call (including operators). This
rule is not applied to the parameters of operators, since otherwise
it would forbid any expression with more than a single operator.
@item
@code{inconsistent_attribute_dimension} controls when no dimension is
explicitely given for a @code{'First}, @code{'Last}, @code{'Range} or
@code{'Length} attribute and the attribute applies to a
multi-dimensional array, or conversely, when an explicit dimension is
given, but the attribute applies to a one-dimensional array.
@item
@code{mixed_operators} controls expressions that involve several
different operators, without parentheses. In a sense, it extends the
language rule that forbids mixing @code{@b{and}} and @code{@b{or}} in
logical expressions to all other operators.
@item
@code{real_equality} controls usage of exact equality or inequality
(``='' or ``/='') between real (floating point or fixed point) values.
@item
@code{slice} controls usage of array slices.
@end itemize

Ex:
@example
search expressions (real_equality, slice);
check  expressions (mixed_operators);
@end example

@node  Global_References, Header_Comments, Expressions, Rules Usage
@section Global_References
@subsection Syntax
@example
<check|search|count> global_references (<Ref_Kind> @{, <Root>@});
Ref_Kind ::= all | multiple | multiple_non_atomic
Root     ::=  <Entity_name> | function | procedure | task | protected
@end example

@subsection Action
This rule controls access to global variables from several entities
(the roots). The @code{<Entity_name>} must be subprograms, task types,
single task objects, protected types, or single protected objects. The
special keywords @code{function}, @code{procedure}, @code{task}, and
@code{protected} are used to refer to all functions, procedures,
tasks, and protected entities, respectively.

If the first parameter (<Ref_Kind) is @code{all}, all references to
global elements from the indicated entities are reported. If the first
parameter is @code{multiple}, only global elements that are accessed
by more than one of the indicated entities (i.e. shared elements) are
reported. Note however that if a reference is found from a task type
or protected type, it is always reported, since there are potentially
several objects of the same type. If the first parameter is
@code{multiple_non_atomic}, references reported are the same as with
@code{multiple}, except that global variables that are @code{atomic}
or @code{atomic_components} and written from at most one of the
indicated entities are not reported. Note that this latter case
corresponds to a safe reader/writer use of atomic variables.

This rule follows the call graph, and therefore finds references from
subprogram and protected calls made (directly or indirectly) from the
indicated entities. However, calls to subprograms from the Ada
standard library are not followed.

Ex:
@example
-- Find global variables used by P1 or P2:
search global_references (all, P1, P2);

-- Find possible race conditions:
check global_references (multiple, task, protected);
@end example

This rule can be given several times, and conflicts (with
@code{multiple}) are reported on a per-rule basis, i.e. given:
@example
check global_references (multiple, P1, P2);
check global_references (multiple, P1, P3);
@end example

the first rule will report on global variables shared between P1 and
P2, and the second rule will report on global variables shared between
P1 and P3.

@subsection Tips
The notion of ``global'' is relative, i.e. it designates every
variable whose scope encloses (strictly) the indicated entities. This
means that a same reference may or may not be global, depending on the
indicated entity. Consider:

@example
@b{procedure} Outer @b{is}
   Inner_V : Integer;

   @b{procedure} Inner_P @b{is}
   @b{begin}
      Inner_V := 1;
   @b{end} Inner_P;
@b{begin}
   Inner_P;
@b{end} Outer;
@end example

The rule
@example
check global_references (all, outer);
@end example
will not report any global reference, while the rule
@example
check global_references (all, outer.inner_p);
@end example
will report a reference to @code{Inner_V}. This is as it should be,
since there is no race condition if several tasks call @code{Outer},
while there is a risk if several tasks (declared inside @code{Outer})
call @code{Inner_P}.

Specifying:
@example
check global_references (all, function);
@end example
will report on any function that access variables outside of their
scope, i.e. all functions that have potential side effects. On the
other hand, this check must follow the whole call graph for any
function encountered, and can therefore be quite costly in execution
time.

@subsection Limitations
Calls through pointers to subprograms and dispatching calls are
unknown statically; they are assumed to not access any global. Such
calls are detected by the rule ``uncheckable''. @xref{Uncheckable}.

@node Header_Comments, Improper_Initialization, Global_References, Rules Usage
@section Header_Comments
@subsection Syntax
@example
<check|search|count> header_comments (minimum, <comment lines>);
<check|search|count> header_comments (model, "<file name>");
@end example
@subsection Action
If the keyword ``minimum'' is given as first parameter, this rule
controls that every compilation unit starts with at least the number
of comment lines indicated by the second parameter. If several forms
of headers are possible, checking that the headers follow the
project's standard requires manual inspection, but this rule is useful
to control that unit headers have not been inadvertantly forgotten.

If the keyword ``model'' is given as first parameter, the second
parameter is a string, interpreted as a file name. If the file name is
not an absolute path, it is interpreted as relative to the directory
of the file that contains the rule, or to the current directory if the
rule is given on the command line.  Each line of the indicated file is
a regular expression, and the rule controls that the corresponding
line of the source file matches the expression. @xref{Syntax of
regular expressions}. However, if a line contains only a single ``*''
character, it means that the next line is a pattern that can be
matched any number of times (including 0).

This rule can be given at most once with ``minimum'' for each of
``check'', ``search'', and ``count''. The rule can be given only once
with ``model'' (but it can be given together with one or more
``minimum'' rules).

Ex:
@example
check header_comments (minimum, 10);
search header_comments (model, "header.pat");
count header_comments (minimum, 20);
@end example
This makes an error for every unit that starts with less than 10
comment lines, and a warning for units that do not follow the pattern
contained in the file @code{header.pat}. A count of units that start
with less than 20 comment lines is reported.

Example of a pattern file:
@example
^--$
^-- Author: .+$
^-- Date: \d@{2@}/\d@{2@}/\\d@{4@}$
@end example

@subsection Tips
Remember that the lines of the file are regular expressions; every
character that is specially interpreted (like ``+'', ``*'', etc.) must
be quoted with ``\'' if it must appear textually. To ease the process
of generating the model file, the directory @code{source} contains a
script file for sed named @code{makepat.sed}; if you run this script
on a file that contains a standard header, it will produce a pattern
file where each line starts with ``^'', ends with ``$'', and every
special character is quoted with ``\''.

@node  Improper_Initialization, Instantiations, Header_Comments, Rules Usage
@section Improper_Initialization
@subsection Syntax
@example
<check|search|count> improper_initialization
   [(<check_kind> @{,<check_kind>@})]
check_kind ::= @{<extra>@} <target>
extra      ::= access | limited
target     ::= out_parameter | variable | initialized_variable
@end example
@subsection Action
This rule controls variables and/or @code{@b{out}} parameters that are
not ``properly'' initialized, i.e. those that are not ``safely''
initialized, those that have a useless initialization in their
declaration, and those where the value is known to be used before
having be assigned.

A variable (or @code{@b{out}} parameter) is considered safely
initialized if there is an initialization expression in its
declaration, or if it is given a value in the first statements of the
corresponding body, until anything other than assignments,
@code{@b{if}} or @code{@b{case}} statements, @code{null} statements,
or procedure calls is encountered.  Variables assigned in
@code{@b{if}} or @code{@b{case}} statements must receive a value in
all paths. The value can be given either through assignment or by
having the variable as an @code{@b{out}} (but not @code{@b{in out}})
parameter of a procedure call.

Note that the variable must be assigned to globally, i.e. assigning to
some elements of an array, or some fields of a record, does not count
as an initialization of the variable.

The <target> parameters determines what is to be checked:
@code{out_parameter} controls that @code{@b{out}} parameters are
safely initialized, @code{variable} controls that local variables are
safely initialized. For these two cases, the rule will also diagnose
when the object is used before being assigned
to. @code{initialized_variable} controls local variable that are
safely initialized, but also have an explicit (and therefore useless)
explicit initialization in their declaration.

Normally, the rule does not control objects of an access types, or
arrays whose components are of an access type, since these are always
initialized by the compiler. Similarly, the rule does not control
objects of a limited type, since global assignment is not available
for them. The <extra> modifiers @code{access} and @code{limited} force
the controlling of these two kinds of objects, respectively.

This rule can be given only once for each value of <target>. Without
parameters, it is equivalent to giving all, without any <extra>.

Ex:
@example
check improper_initialization (out_parameter);
check improper_initialization (access limited variable);
search improper_initialization (initialized_variable);
@end example

@subsection Limitations
Due to a weakness of the ASIS standard, dispatching calls and calls to
procedures that are attributes are not considered for the
initialization of variables. Note that for attributes, only
@code{'Read} and @code{'Input} have an @code{@b{out}} parameter.

In the rare case where a variable is initialized by a dispatching call
or an attribute call, this limitation will result in a false
positive. Such a case is detected by the rule
``uncheckable''. @xref{Uncheckable}. It is then easy to disable the
rule for this variable. @xref{Disabling rules}.

There are other cases where an object is automatically initialized by
the declaration, like controlled types that have redefined the
@code{Initialize} procedure, records where all components have a
default initialization, etc. The rule does not consider these as
automatically initialized, as it does for access types. Maybe later...

@node Instantiations, Insufficient_Parameters, Improper_Initialization, Rules Usage
@section Instantiations
@subsection Syntax
@example
<check|search|count> instantiations (<generic_spec>);
generic_spec ::= @{<location_kw>@} <generic name> @{, <entity name> | <> | =@}
location_kw ::= all    | block    | local | nested | own | private |
                public | task_body
@end example

@subsection Action
This rule controls all instantiations of a generic, or only
instantiations that are made with specific values of the
parameters. Control can be restricted to instantiations in specified
places.

The <location_kw> restricts the places where the occurrence of the
instantiation is controlled.  Several <location_kw> can be given, in
which case the instantiation is controlled at places where all the
keywords apply. If there is no <location_kw>, it is assumed to be
``all''.
@itemize @bullet
@item
@code{all}: puts no special restriction to the location. This keyword
can be specified for readability purposes, and if specified must
appear alone (not with other <location_kw>).
@item
@code{block}: only instantiations appearing in block statements are
controlled.
@item
@code{local}: only local instantiations are controlled (i.e. only
instantiations appearing in (generic) packages, possibly nested, are
allowed).
@item
@code{nested}: only instantiations nested in another declaration are
controlled (i.e. only library level instantiations are allowed).
@item
@code{own}: only instantiations that are local to a (generic) package
body are controlled.
@item
@code{public}: only declarations appearing in the visible part of
(generic) packages are controlled.
@item
@code{private}: only instantiations appearing directly in a private
part are controlled.
@item
@code{task_body}: only instantiations appearing directly in a task
body are controlled. Note that it would not make sense to have a
<location_kw> for task @i{specifications}, since instantiations are
not allowed there.
@end itemize

An instantiation matches if it appears at a specified location (if
any) and either:
@enumerate
@item
No entity name is given in the rule
@item
The entity names given are the same as the first parameters of the
instantiation (i.e. there can be more actual parameters in the
instantiation than specified in the rule). Two special signs can be
given instead of an entity name: a box (@code{<>}) matches any actual
parameter (i.e. it stands for any value), and an equal sign (@code{=})
matches if there has been already an instantiation with the same value
for this parameter (i.e. it matches the second time it is encountered).
@end enumerate

If an actual is an expression (which is possible only for a formal
@code{@b{in}} object), it cannot be matched.

Ex:
@example
-- Check all instantiations of Unchecked_Deallocation:
search instantiations (ada.unchecked_deallocation);

-- Check all instantiations of Unchecked_Conversion from or to String:
check instantiations (ada.unchecked_conversion, standard.string);
check instantiations (ada.unchecked_conversion, <>, standard.string);

-- Check that Unchecked_Conversion is instantiated only once
-- for any pair of arguments:
check instantiations (ada.unchecked_conversion, =, =);
@end example

@subsection Tips
As usual, all forms of entity specification can be given, which makes the
rule quite powerful. For example:
@example
-- Not two instantiations of Gen with the same first parameter:
check instantations (Gen, =);

-- Not two instantiations of Gen with the same first and third parameter:
check instantiations (Gen, = <>, =);

-- Not two instantiations of Gen with the same first parameter if the
-- second parameter is Pack.Proc:
check instantiations (Gen, =, Pack.Proc);

-- Not two instantiations of Gen with the same first parameter if the
-- second parameter is any procedure named Proc:
check instantiations (Gen, =, all Proc);
@end example

@subsection Limitation
Gnat defines @code{Unchecked_Conversion} and
@code{Unchecked_Deallocation} as separate entities, rather than
renamings of @code{Ada.Unchecked_Conversion} and
@code{Ada.Unchecked_Deallocation}. As a consequence, it is necessary
to specify explicitely both forms if you want to make sure that the
corresponding generics are not instantiated.

@node  Insufficient_Parameters, Local_Hiding, Instantiations, Rules Usage
@section Insufficient_Parameters
@subsection Syntax
@example
<check|search|count> insufficient_parameters
                       (<Max_Allowed> @{, <Type_Name>@});
@end example
@subsection Action
This rule controls calls to subprograms and entries where the values
of parameters does not provide sufficient information to the reader to
correctly identify the parameter's purpose. <Max_Allowed> is the
maximum number of  allowed ``insufficient'' parameters (can be 0).
<Type_Name> designates enumeration types whose values should be
included in the check.

An actual parameter is deemed "insufficient"  if it is given in
positional (as opposed to named) notation, it is an expression whose
primaries are all numeric literals, or enumeration literals belonging
to one of the types passed as parameters to the rule
(@code{Standard.Boolean} for example).

This rule can be given once for each of check, search, and count. This
way, it is possible to have a level considered a warning (search), and
one considered an error (check).

Ex:
@example
search Insufficient_Parameters (1, Standard.Boolean);
check  Insufficient_Parameters (2, Standard.Boolean);
@end example

@subsection Tips
This rule does not apply to operators that use infix notation, nor to
calls to subprograms that are attributes, since named notation is not
allowed for these.

This rule controls the use of positional parameters according to their
values; it is also possible to control the use of positional
parameters according to the number of parameters with the rule
@code{style (positional_association)}. @xref{Style}.

Note also that this rules applies only to calls, while @code{style
(positional_association)} applies to all forms of associations.

@node Local_Hiding, Max_Blank_Lines, Insufficient_Parameters, Rules Usage
@section Local_Hiding
@subsection Syntax
@example
<check|search|count> local_hiding [(<subrule> @{,<subrule>@})];
<subrule> ::= strict | overloading
@end example

@subsection Action
This rule controls declarations that hide an outer declaration with
the same name. If ``strict'' is given (or if there is no subrule), the
rule controls strict hiding (an inner subprogram that overloads an
outer one is not considered hiding). If ``overloading'' is given, only
subprograms that overload another subprogram in the same scope or in
an outer scope are controlled.

This rule  can be given only once for strict and once for overloading.

Ex:
@example
Hiding: check local_hiding (strict);
Overloading: search local_hiding (overloading);
@end example

@node Max_Blank_Lines, Max_Call_Depth, Local_Hiding, Rules Usage
@section Max_Blank_Lines
@subsection Syntax
@example
<check|search|count> max_blank_lines (<max allowed blank lines>);
@end example

@subsection Action
This rule controls the occurrence of more than the indicated number of
consecutive blank lines (empty lines, or lines that contain only
spaces). This rule can be given once for each of check, search, and
count. This way, it is possible to have a number of blank lines
considered a warning (search), and one considered an error (check). Of
course, this makes sense only if the number for search is less than
the one for check.

Ex:
@example
search max_blank_lines (2);
check max_blank_lines (5);
@end example

@node Max_Call_Depth, Max_Line_Length, Max_Blank_Lines, Rules Usage
@section Max_Call_Depth
@subsection Syntax
@example
<check|search|count> Max_Call_Depth (<allowed depth> | finite);
@end example
@subsection Action
This rule controls the maximum depth of subprograms (or entry) calls;
roughly, the call depth is the number of frames that are stacked by a
call: if you call a subprogram that calls another subprogram that
calls nothing, then the call depth is 2. Note that a call to a task
(not protected) entry has always a depth of 1, since the accept body
that corresponds to the entry is executed on a different stack.

The value of the parameter is the maximum @i{allowed} depth, i.e. the
rule will trigger if the call depth is strictly greater than the
indicated value. A call to a (directly or indirectly) recursive
procedure is considered of infinite depth, and will be therefore
signaled (with an appropriate message) for any value of <allowed
depth>. Alternatively, the keyword ``finite'' can be given in place of
the <allowed depth>: in this case, only calls to recursive subprograms
will be signalled.

This rule can be given once for each of check, search, and count. This
way, it is possible to have a call depth considered a warning
(search), and one considered an error (check). Of course, this makes
sense only if the number for search is less than the one for check.

Ex:
@example
search max_call_depth (9);
check  max_call_depth (finite);
@end example

@subsection Tip
It is possible to give the value 0 for <allowed depth>. Of course,
it would not make sense to forbid all subprogram calls in an Ada program,
but this can be useful for inspection purposes, since every call will be
reported, and the message indicates the depth of the call.

@subsection Limitations
Calls to attributes, predefined operators, etc. are assumed to have a
depth of 1.

Calls through pointers to subprograms and dispatching calls are unknown
statically; they are assumed to have a depth of 1. Such calls are
detected by the rule ``uncheckable''. @xref{Uncheckable}.

@node  Max_Line_Length, Max_Nesting, Max_Call_Depth, Rules Usage
@section Max_Line_Length
@subsection Syntax
@example
<check|search|count> max_line_length (<max allowed length>);
@end example

@subsection Action
This rule controls the maximum length of source lines.  This rule can
be given once for each of check, search, and count. This way, it
is possible to have a length considered a warning (search), and one
considered an error (check). Of course, this makes sense only if the
length for search is less than the one for check.

Ex:
@example
search max_line_length (80);
check max_line_length (120);
@end example

@node Max_Nesting, Max_Parameters, Max_Line_Length, Rules Usage
@section Max_Nesting
@subsection Syntax
@example
<check|search|count> max_nesting (<max allowed depth>);
@end example

@subsection Action
This rule controls the nesting of declarative
constructs (like subprograms, packages, generics, block
statements@dots{}) that exceed a given depth. Nesting of statements
(@code{@b{loop}}, @code{@b{case}}) is not considered. This rule can be
given once for each of check, search, and count. This way, it
is possible to have a level considered a warning (search), and one
considered an error (check). Of course, this makes sense only if the
level for search is less than the one for check.

Ex:
@example
search max_nesting (5);
check max_nesting (7);
@end example

@node Max_Parameters, Max_Size, Max_Nesting, Rules Usage
@section Max_Parameters
@subsection Syntax
@example
<check|search|count> max_parameters (<max_allowed>, @{,<entity_kw>@});
entity_kw ::= function           | procedure           | protected_entry |
              protected_function | protected_procedure |task_entry
@end example
@subsection Action
This rule controls declarations of callable entities that have more
parameters than the specified allowed value. If one or more <entity_kw>
is specified, the rule applies only to the corresponding declaration(s),
otherwise it applies to all callable entities.

This rule can be given once for each of check, search, and count for
each kind of entity. This way, it is possible to have a level
considered a warning (search), and one considered an error (check). Of
course, this makes sense only if the level for search is less than the
one for check.

Ex:
@example
check max_parameters (10, procedure, function);
search max_parameters (5, procedure, function);
count max_parameters (5);
@end example

@subsection Tips
This rule applies to generic subprograms as well as to regular ones.
On the other hand, it does not apply to generic formal subprograms,
since instantiations would only be possible with subprograms which
are supposed to have been already controlled.

Instantiations are also controlled; the number of parameters is taken
from the corresponding generic.

Note that this rule controls only ``regular'' parameters, not generic
formal parameters.

@node Max_Size, Max_Statement_Nesting, Max_Parameters, Rules Usage
@section Max_Size
@subsection Syntax
@example
<check|search|count> Max_Size (<stmt_kw>, <max allowed lines>);
<stmt_kw> ::= accept        | block        | case  | case_branch   |
              if            | if_branch    |loop   | simple_block  |
              unnamed_block | unnamed_loop
@end example
@subsection Action
This rule controls the maximum size, in source lines of code, of
various statements.  ``block'' controls all block statements, while
``simple_block'' controls only blocks without a @code{@b{declare}}
part, and ``unnamed_block'' controls only blocks without a
name. Similarly, ``loop'' controls all loop statement, while
``unnamed_loop'' controls only loops without a name. ``if_branch'' and
``case_branch'' control the length of each alternative of an
@code{@b{if}} (respectively @code{@b{case}} statement.

For each kind of statement, the indicated value is the maximum allowed
size of the full statement; however, for branches (``if_branch'' and
``case_branch'') it is the maximum size of the sequence of statements
in the branch (i.e., the line that contains the @code{@b{elsif}} is
not counted as part of an ``if_branch'').

This rule can be given once for each of check, search, and count for
each kind of statement. This way, it is possible to have a level
considered a warning (search), and one considered an error (check). Of
course, this makes sense only if the number of lines for search is
less than the one for check.

Ex:
@example
check Max_Size (if_branch, 30);
search Max_Size (if_branch, 50);
check Max_Size (unnamed_loop, 20);
@end example

@node Max_Statement_Nesting, Movable_Accept_Statements, Max_Size, Rules Usage
@section Max_Statement_Nesting
@subsection Syntax
@example
<check|search|count> Max_Statement_Nesting (<stmt_kw>, <max allowed depth>);
<stmt_kw> ::= block | case | if | loop | all
@end example
@subsection Action
This rule controls the nesting of compound statements. If one of
``block'', ``case'', ``if'', or ``loop'' is specified, it controls
the nesting of statements of the same kind, i.e. an @code{@b{if}} within a
@code{@b{loop}} within an @code{@b{if}} counts only 2 for the ``if''
keyword. If ``all'' is specified, all kinds of compound statements are
counted together, i.e. an @code{@b{if}} within a @code{@b{loop}}
within an @code{@b{if}} counts for 3. This rule can be given once for
each of check, search, and count, and for each of the subrules. This way,
it is possible to have a level considered a warning (search), and one
considered an error(check). Of course, this makes sense only if the level
for search is less than the one for check.

Ex:
@example
check max_statement_nesting (loop, 3);
search max_statement_nesting (all, 5);
@end example

@node Movable_Accept_Statements, Multiple_Assignments, Max_Statement_Nesting, Rules Usage
@section Movable_Accept_Statements
@subsection Syntax
@example
<check|search|count> movable_accept_statements
   (certain|possible [, <entity_list>])
<entity_list> ::= <entity name> @{, <entity name>@}
@end example
@subsection Action
This rule controls statements that are inside accept statements and
could safely be moved outside.  Since it is good practice to block a
client for the shortest time possible, any action that does not depend
on the accept parameters should not be part of an accept statement.

Statements that involve synchronisation (delay statements, accept or
entry calls...) are not movable.  Statements (including compound
statements) that reference the parameters of the enclosing accept are
not movable.  In addition, statements that use entities whose names
are given as parameters to the rule are never considered movable. Note
that if a generic entity name is given, or the name of an entity
declared in a generic package, all statements that use the
corresponding instantiated entity are considered not movable.

If the first parameter of the rule is @code{certain}, only statements
after the last non-movable statement are reported.  If the first
parameter is @code{possible}, a simple data flow analysis is
performed, and every statement that does not reference a variable that
appears to depend (directly or indirectly) on a parameter is also
reported.

Ex:
@example
check movable_accept_statements (possible, Log.Report_Rendezvous);
@end example

@subsection Tips
The entity names given to the rule can be, for example, procedures
whose execution must be part of the accept statement for logical
reasons. They can also be global variables,  when the rendezvous is
intended to prevent concurrent access to these variables.

@node  Multiple_Assignments, Naming_Convention, Movable_Accept_Statements, Rules Usage
@section Multiple_Assignments
@subsection Syntax
@example
<check|search|count> Multiple_Assignments (repeated);
<check|search|count> Multiple_Assignments (groupable, <filter> @{,<filter>@});
<criterion> ::= given <min_val> | missing <max_val> | ratio <min_val>
@end example
@subsection Action
This rule controls properties of groups of assignment statements. A
group is made of consecutive assignments, without any other
intervening kind of statements (except null statements).

The first form (keyword ``repeated'') controls when a same variable
(or a same subcomponent of a structured variable) is assigned several
times in the same group of assignments. This form of the rule can be
given only once.

The second form (keyword ``groupable'') controls assignments to
different subcomponents of a same structured variable; such
assignments are often replaceable by a global assignment of an
aggregate to the variable. One or several <filter> parameters
indicate under which conditions a group is reported:
@itemize @bullet
@item
``given'': <min_val> (an integer value) indicates the minimum number
of assigned subcomponents that will trigger the rule (i.e. the rule is
triggered if  the number of assignments to subcomponents of a same
variable is greater or equal to the indicated value).
@item
``missing'': <max_val> (an integer value) indicates the maximum number
of subcomponents not assigned that will trigger the rule (i.e. the
rule is triggered if  the number of subcomponents not assigned to is
lesser or equal to the indicated value).
@item
``ratio'': <min_val> (an integer value) indicates the minimum
percentage of assigned subcomponents that will trigger the rule
(i.e. the rule is triggered if  the percentage of assigned
subcomponents is greater or equal to the indicated value).
@end itemize

If several filters are given, the rule is triggered if all conditions
are met (``and'' logic). Note however that this rule can be given
several times, thus achieving ``or'' logic.

The rule is @i{not} triggered if the subcomponents belong to a
stuctured variable of a limited type, since global assignment would
not be allowed in that case.

Ex:
@example
check Multiple_Assignments (repeated);

-- Warn if a at least 3 fields are given and at most
-- two fields are missing, or if 80% of the fields are given:
search multiple_assignments (groupable, given 3, missing 2);
search multiple_assignments (groupable, ratio 80);
@end example

@subsection Tip
Note that it is possible to give 1 for the ``given'' criterion; in
this case, any assignment to parts of a structured variable will be
reported, only global assignment is allowed.

@subsection Limitations
As usual, AdaControl can control only static aspects of
assignments. Therefore, it cannot control assignments whose target is
not statically known (like dynamic indexing of arrays). Slices are
always considered dynamic (the cases where it would be useful did not
seem  worth the additional complexity).

Similarly, if the number of subcomponents is not statically
determinable (dynamic arrays, discriminated records), only the
``given'' criterion can be met.

@node Naming_Convention, No_Operator_Usage, Multiple_Assignments, Rules Usage
@section Naming_Convention
@subsection Syntax
@example
<check|search|count> naming_convention
   ([root] @{<Location>@} <Filter_Kind>,
    [case_sensitive|case_insensitive] [not] "<Pattern>"
    @{, ...@});
<Location> ::= global | local | unit
<Filter_Kind> ::= All |
                    Type |
                       Discrete_Type |
                          Enumeration_Type |
                          Integer_Type |
                             Signed_Integer_Type |
                             Modular_Integer_Type |
                          Floating_Point_Type |
                          Fixed_Point_Type |
                             Binary_Fixed_Point_Type |
                             Decimal_Fixed_Point_Type |
                       Array_Type |
                       Record_Type |
                          Regular_Record_Type |
                          Tagged_Type |
                          Class_Type |
                       Access_Type |
                          Access_To_Regular_Type |
                          Access_To_Tagged_Type |
                          Access_To_Class_Type |
                          Access_To_SP_Type |
                          Access_To_Task_Type |
                          Access_To_Protected_Type |
                       Private_Type |
                          Private_Extension |
                       Generic_Formal_Type |
                    Variable |
                       Regular_Variable |
                       Field |
                          Discriminant |
                          Record_Field |
                          Protected_Field |
                       Procedure_Formal_Out |
                       Procedure_Formal_In_Out |
                       Generic_Formal_In_Out |
                    Constant |
                       Regular_Constant |
                       Named_Number |
                          Integer_Number |
                          Real_Number |
                       Enumeration |
                       Sp_Formal_In |
                       Generic_Formal_In |
                       Loop_Control |
                       Occurrence_Name |
                       Entry_Index |
                    Label |
                    Stmt_Name |
                       Loop_Name |
                       Block_Name |
                    Subprogram |
                       Procedure |
                          Regular_Procedure |
                          Protected_Procedure |
                          Generic_Formal_Procedure |
                       Function |
                          Regular_Function |
                          Protected_Function |
                          Generic_Formal_Function |
                       Entry |
                          Task_Entry |
                          Protected_Entry |
                   Package |
                       Regular_Package |
                       Generic_Formal_Package |
                    Task |
                       Task_Type |
                       Task_Object |
                    Protected |
                       Protected_Type |
                       Protected_Object |
                    Exception |
                    Generic |
                       Generic_Package |
                       Generic_Sp |
                          Generic_Procedure |
                          Generic_Function
@end example

@subsection Action
This rule controls the declaration of identifiers that do not follow
the project's naming conventions. The first parameter defines the kind
of declaration to which the rule is applicable, and other parameters
are strings, interpreted as regular expressions that define the patterns
that must be matched. @xref{Syntax of regular expressions}.

If one or more <Location> keyword is specified, the pattern applies
only to identifiers.  Otherwise, the pattern applies to all
identifiers, irrespectively of where they are declared. The definition
of locations is as follows:
@itemize @bullet
@item
``unit'': The identifier is the defining name of a compilation unit.
@item
``global'': The identifier is  declared in a package or a  generic
package, possibly nested in other packages or generic packages.
@item
``local'': All other cases.
@end itemize

If ``case_sensitive'' is specified, pattern matching considers
casing. Otherwise (default or ``case_insensitive''), casing is
irrelevant. Note that the rule checks the name only at the place where
it is declared; casing might be different when the name is used later.

If a pattern is preceded by ``not'', then the pattern must @i{not} be
matched (i.e. the rule reports when there is a match).

The rule will be activated if an identifier is declared that does not
match any of the ``positive'' patterns (the ones without ``not''), or
if it matches any of the ''negative'' patterns (the ones with a
``not''). If only negative patterns are given, it is implicitely
assumed that all other identifiers are OK. In other words, accepted
identifiers must have the form of (at least) one of the ``positive''
patterns (if any), but not the form of one of the ``negative''
patterns.

The filter kinds are organized hierarchically, as reflected in the
syntax above. To be valid, the name must match the patterns specified
for its own filter, and for all filters above it in the hierarchy.
For example, a modular type declaration must follow the rules (if
specified) for ``all'', ``type'',''discrete_type'', ``integer_type''
and ``modular_integer_type''. However, if a filter kind is preceded by
``root'', rules above it in the hierarchy are not considered (neither
for itself not its children). This is useful to make exceptions to a
more general rule.

It is of course not necessary to specify all the filter kinds, nor to
specify filters down to the deepest level; if you specify a rule for
``type'', it will be applied to all type declarations, whether there
is a more specific rule or not.

For renamings, the applicable rule is the one for the renamed
entity. Similarly, subtypes and derived types must follow the rule for
their respective original (full) type. Incomplete type declarations
are @i{not} checked, since their corresponding full declaration is
(normally) checked. Private types (including of course the full
declaration of a private type) follow the rule for private types,
@i{not} the rules for their full type view (otherwise it would be
privacy breaking).

Ex:
@example
-- All identifiers must have at least 3 characters:
check naming_convention (all, "...");

-- Predefined name is forbidden:
check naming_convention (all, not "Integer");

-- Types must either start or end with T
check naming_convention (type, case_sensitive "^T_",
                               case_sensitive "_T$");

-- Exception to the rule for "all":
-- No minimum length for "for loop" identifiers
check naming_convention (root loop_control, ".");

-- "Upper_Initials" naming convention:
check naming_convention
   (all, case_sensitive "^[A-Z][a-z0-9]*(_[A-Z0-9][a-z0-9]*)*$");

-- All global variables must start with "G_"
check naming_convention (global variable, "G_");
@end example

@subsection Tips
Remember that a Regexp matches if the pattern matches any part of the
identifier.  Use ``^'' and ``$'' to match the beginning (resp. end) of
the name, or both.

``class_type'' is applicable to subtypes that designate a class-wide
type. Similarly, ``access_to_class_type'' is applicable to access
types whose designated type is class-wide.

The @code{rules} directory of Adacontrol contains two files named
@code{no_standard_entity.aru} and @code{no_system_entity.aru}. These
are files that contain a naming_convention rule that forbids the
declaration of names declared in packages @code{Standard} and @code{System},
respectively. You can simply ``source'' these files from your own rule
file (or copy the content) if you want to disallow these identifiers.

Like usual, naming_convention rule can be given multiple times, and
can be disabled. However, consider the following:
@example
Rule1 : check naming_convention (constant, "^c_");
Rule2 : check naming_convention (constant, "^const_");
@end example
The rule will trigger if a constant is declared that does not start
with either ``c_'' or ``const_''. But here, we have two different
rule labels. The message will refer to the first label encountered in the
rule file; this is the label that must be mentionned in a disabling
comment, unless you simply disable ``naming_convention''.

@subsection Limitations
This rule does not support wide characters outside the basic Latin-1 set.

@node No_Operator_Usage, Non_Static, Naming_Convention, Rules Usage
@section No_Operator_Usage
@subsection Syntax
@example
<check|search|count> no_operator_usage [(none | logical)];
@end example
@subsection Action
This rule controls integer types (both signed and modular) where no
operator of the type is used in the program (if the keyword @code{none}
is given), or only logical operators (if the keyword @code{logical} is
given). If no parameter is given, the rule will control both cases.

An integer type that uses no operator at all is a good candidate to be
replaced by an enumerated type. A modular type where only logical
operators are used is likely to be used as a bit field or a set, and
is a good canditate for being replaced by an array of booleans.

This rule can be given only once for each value of the parameters.

Ex:
@example
check no_operator_usage;
@end example

@subsection Tips
The rule does not make a distinction between predefined and
user-defined operators. On the other hand, only call to operators are
considered, operators used for example as actual generic parameters in
instantiations are not considered.

The rule applies to private types whose full declaration is an integer
type.

@node Non_Static, Not_Elaboration_Calls, No_Operator_Usage, Rules Usage
@section Non_Static
@subsection Syntax
@example
<check|search|count> non_static [(context_kw @{, context_kw@})];
<context_kw> ::= constant_initialization | variable_initialization |
                 index_constraint        | discriminant_constraint | 
                 instantiation
@end example

@subsection Action
This rule controls that expressions used in certain contexts are
static, as indicated by <context_kw>:
@itemize @bullet
@item
``constant_initialization'': expressions used as initial value in
constant declarations.
@item
``variable_initialization'': expressions used as initial value in
variable declarations.
@item
``index_constraint'': expressions used in index constraints (aka array
sizes).
@item
``discriminant_constraint'': expressions used in discriminant
constraints
@item
``instantiation'': expressions used as generic actual parameters in
instantiations.
@end itemize

If no keyword is given, all contexts are controlled.

Ex:
@example
check non_static (index_constraint);
@end example

@subsection Limitations
Currently, ``constant_initialization'' and ``variable_initialization''
do not control structured (record and array) variables. For access
variables, the initial value is considered static only if it is a plain
@code{@b{null}}. This may improve in future versions of AdaControl.

@subsection Tips
If all index and discriminant constraints are static, the space
occupied by data structures is computable from the program text. This
rule is useful to enforce this in contexts where the memory space must
be statically determined.

@node Not_Elaboration_Calls, Not_Selected_Name, Non_Static, Rules Usage
@section Not_Elaboration_Calls
@subsection Syntax
@example
<check|search|count> not_elaboration_calls
   (<subprogram name> @{, <subprogram name>@});
@end example

@subsection Action
This rule controls subprogram calls (procedure, function or entry
calls) that are performed at any time except during the elaboration of
library packages.

Ex:
@example
search not_elaboration_calls (Data.Initialize);
@end example

@subsection Limitations
Due to an (allowed by ASIS standard) limitation of ASIS-for-Gnat, the
rule will not detect calls to subprograms that are implicitely
defined, like calling a @code{"+"} on @code{Integer}. Fortunately,
it is very unlikely that the user would want to forbid that kind of
calls in non-elaboration code.

Note also that calls that cannot be statically determined, like calls
to dispatching operations or calls through pointers to subprograms
cannot be detected either.

@node Not_Selected_Name, Parameter_Aliasing, Not_Elaboration_Calls, Rules Usage
@section Not_Selected_Name
@subsection Syntax
@example
<check|search|count> not_selected_name
   (<exception places>, <entity> @{, <entity>@});
<exception places> ::= none | unit | compilation | family
@end example
@subsection Action
This rule controls that certain entities are always refered to using
selected notation (i.e. prefixed by the name of the construct where
they are declared). Only one level of prefix is required, unless the
prefix itself is the target of a not_selected_name rule.

The first parameter specifies places where the rule is @i{not}
enforced, i.e. where simple notation is allowed:
@itemize @bullet
@item
``none'': selected notation is always required.
@item
``unit'': selected notation is not required within the program unit
where the entity is declared.
@item
``compilation'': selected notation is not required within the
compilation unit where the entity is declared.
@item
``family'': selected notation is not required within the compilation
unit where the entity is declared, nor within its (direct or indirect)
children.
@end itemize

Other parameters indicate the entities to which the rule applies.

Ex:
@example
check not_selected_name (unit, all Instance);
search not_selected_name (none, Pack.T);
@end example

@subsection Tip
Note that, as usual, the entity can be given in the form ``all
name''. This is especially useful for types that must always be
declared with a special name (like @code{Instance}, @code{Object},
@code{T}) and are intended to be always used with the name of the
enclosing package.

@node  Parameter_Aliasing, Other_Dependencies, Not_Selected_Name, Rules Usage
@section Parameter_Aliasing
@subsection Syntax
@example
<check|search|count> parameter_aliasing [([with_in] <level>)];
<level> ::= Certain | Possible | Unlikely
@end example

@subsection Action
This rule controls aliased use of variables in subprogram
calls. Specifically, this rule will identify calls where the same
variable is given as an actual to more than one @code{@b{out}} or
@code{@b{in out}} parameter, like in the following example:
@example
@b{procedure} Proc (X, Y : @b{out} Integer);
   ...
Proc (X => V, Y => V);
@end example

If the modifier ``@code{with_in}'' is given, aliasing between
@code{@b{out}} or @code{@b{in out}} parameters and @code{@b{in}}
parameters is also considered. Although this is generally considered
of less of an issue, it can lead to unexpected results when the
@code{@b{in}} parameter is passed by reference.

There are many cases where aliasing cannot be determined
statically. The optional parameter specifies how aggressively the
rule will check for possible aliasings. Possible values are (case
irrelevant):
@itemize
@item
Certain (default): Only cases where aliasing is statically certain are
output.
@item
Possible: In addition, cases where aliasing may occur depending on
the value of an indexed component are output. These may or may not be
true aliasing, depending on the algorithm. For example, given:
@example
Swap (Tab (I), Tab (J));
@end example
there is no aliasing, unless @code{I} equals @code{J}.

If all expressions used for indexing in both variables are static, the
rule will be able to eliminate the diagnosis of aliasing (if the
values are different). This avoids unnecessary messages in cases like:
@example
Swap (Tab (1), Tab (2));
@end example

@item
Unlikely: In addition, cases where aliasing may occur due to access
variables pointing to the same variable are output. These may or may
not be true aliasing, depending on the algorithm, but should normally
occur only as the result of very strange practices, like in the
following example:
@example
@b{type} R @b{is}
   @b{record}
      X : @b{aliased} Integer;
   @b{end} @b{record};
X : R;
Y : Access_All_Integer := R.X'access;
   ...
P (X, Y.all);
@end example
@end itemize
There will be no false positive with ``Certain''. There will be no
false negative with ``Unlikely'' (but many false
positives). ``Possible'' is somewhere in-between.

The rule may be specified at most once for each value of the
parameter. This allows for example to ``check'' for ``Certain'' and
``search'' for ``Possible''.

Ex:
@example
check parameter_aliasing (with_in certain);
search parameter_aliasing (Possible);
@end example

Note that the rule is quite clever: it will consider partial aliasing
(like a record variable as one parameter, and one of its components as
another parameter), and will not be fooled by renamings.

@subsection Limitation
Due to a weakness of the ASIS standard, dispatching calls  are not
considered. This limitation will be removed as soon as we find a way
to work around this problem, but the issue is quite difficult!

@node Other_Dependencies, Potentially_Blocking_Operations, Parameter_Aliasing, Rules Usage
@section Other_Dependencies
@subsection Syntax
@example
<check|search|count> other_dependencies (<unit> @{,<unit>@});
@end example
@subsection Action
This rule controls semantic dependencies (i.e. @code{@b{with}} clauses)
to units other than those indicated. This rule can be specified only
once.

Ex:
@example
check other_dependencies (Ada.Text_IO);
@end example

@node  Potentially_Blocking_Operations, Pragmas, Other_Dependencies, Rules Usage
@section Potentially_Blocking_Operations
@subsection Syntax
@example
<check|search|count> potentially_blocking_operations;
@end example

@subsection Action
This rule controls usage of potentially blocking operations (as
defined in LRM 9.5.1 (8..16)) from within protected operations. It
does follow the call graph, therefore identifying indirect potentially
blocking operations. All protected types in the program are controlled.

Of course, calls to standard subprograms (notably IOs) that are
defined to be potentially blocking are recognized.

Ex:
@example
check potentially_blocking_operation;
@end example

@subsection Tips
This rule is very clever at finding potentially blocking operations
resulting from external calls (or requeues) to the current protected
object, even if this happens through a long chain of subprogram
calls. Typically, this happens when a protected operation calls a
subprogram, which in turn makes a call to an operation of the same
protected object. Such calls generally result in dead-locks.

Therefore, it is advisable to run this rule on any program that
exhibits mysterious (and hard to find) deadlocks that seem to involve
protected objects.

When a single protected object is being analyzed, the rule will
diagnose a circularity if there is a call to an operation of the same
object in the call chain; however, if a protected type is being
analyzed, the rule will diagnose a circularity if there is a call to
any object of the same type in the call chain. Although it is possible
to construct examples of this latter case where there is no risk of
deadlock, it is so contrieved that it certainly deserves being looked
at. But since the call is not 100% certain to be potentially blocking,
the message will tell ``possible external call'' instead of ``external
call'' in this case.

@subsection Limitation
There is one case defined in LRM E.4(17) which is not recognized:
remote subprograms calls.

Calls through pointers to subprograms and dispatching calls are
unknown statically; they are assumed to be non potentially
blocking. Such calls are detected by the rule
``uncheckable''. @xref{Uncheckable}.

@node Pragmas, Reduceable_Scope, Potentially_Blocking_Operations, Rules Usage
@section Pragmas
@subsection Syntax
@example
<check|search|count> pragmas
    (all|nonstandard|<pragma name> @{, <pragma name>@});
@end example

@subsection Action
This rule controls usage of one or several specific pragmas. If the
special name ``nonstandard'' is given, then all implementation-defined
and unrecognized pragmas will be controlled.  If the special name
``all'' is given, then all pragmas will be controlled.  Ex:
@example
check pragmas (elaborate_all, elaborate_body);
@end example

@subsection Tips
If ``all'' and/or ``nonstandard'' is given together with a specific
pragma name in a ``search'' or ``check'' rule, a message is issued
only for the most specific occurrence. However, for ``count'', all
appropriate occurrences are counted, i.e. given the following rules:
@example
C1 : count pragmas (annotate);
C2 : count pragmas (nonstandard);
C3 : count pragmas (all);
@end example
Counter C1 will report the number of occurrences of @code{@b{pragma}
Annotate} (a non-standard Gnat pragma), counter C2 will report the
number of non-standard pragmas (including occurrences of
@code{Annotate}), and counter C3 will report the total number of
pragmas (including occurrences of @code{Annotate}).

@node Reduceable_Scope, Representation_Clauses, Pragmas, Rules Usage
@section Reduceable_Scope
@subsection Syntax
@example
<check|search|count> reduceable_scope [(<target> @{, <target>@})];
<target> ::= [no_blocks] all     | variable  | subprogram | type
                         package | exception | generic    | use
@end example
@subsection Action
This rule controls declarations that could be moved to some inner
scope. More precisely, it will report on any declaration that is
referenced only from a single, inner scope, or in the case of
@code{@b{use}} clauses, it will report on packages named in a
@code{@b{use}} clause whose elements are used only in a single, inner
scope. However, entities that are used as prefixes of a 'Access or
'Address attribute are never reported, since moving them would change
their accessibility level. Similarly, task objects are not reported
since moving them would change their master. Finally, dispatching
operations (primitive operations of tagged types) are not reported
either, since they can be the target of an ``invisible'' (dispatching)
call.

If no <target> is given, all declarations are controlled (``all''
stands for all other subrules). If @code{no_blocks} is specified in
front of a subrule, the rule will not consider blocks as possible
targets for a reduced scope for the corresponding category. Specifying
``all'' explicitely is only useful in the case of ``no_blocks all''.

As a side effect, the rule will report about entities that are
declared but not used (i.e. whose scope reduces to nothing).

Ex:
@example
check reduceable_scope (variable, type);
check reduceable_scope (no_blocks subprogram, no_blocks package);
search reduceable_scope (use);
@end example

@subsection Tips
Variables that are initialized at their declaration are never
considered as movable to a more reduced scope, since the
initialization itself is a use of the variable (in its outermost
scope). For the same reason, constants are never considered by this
rule.

If you think that @code{@b{use}} clauses are acceptable, but should be
limited to the smallest possible scope, you would generally specify:
@example
check unnecessary_use_clause;
check reduceable_scope (use);
@end example

@node  Representation_Clauses, Return_Type, Reduceable_Scope, Rules Usage
@section Representation_Clauses
@subsection Syntax
@example
<check|search|count> representation_clauses
   [(<repr_kw>|<attribute> @{, <repr_kw>|<attribute>@}, ... )];

repr_kw ::= at              | at_mod            | enumeration           | 
            fractional_size | incomplete_record | non_contiguous_record | 
            record
@end example

@subsection Action
This rule controls usage of representation clause. Without parameter,
it will control all representation clauses, otherwise it will control the
representation clauses given as parameter.
@itemize @bullet
@item
``at'' controls address clauses given in Ada 83 style (``for XXX use
at'').
@item
``at_mod'' controls alignment clauses given in Ada 83 style (``for T
use record at mod XX;'').
@item
``enumeration'' controls enumeration representation clauses.
@item
``fractional_size'' controls size clauses whose value is not an integral
multiple of @code{System.Storage_Unit}.
@item
``incomplete_record'' controls record representation clauses that miss
the specification of some components of the record's type.
@item
``non_contiguous_record'' controls record representation clauses where
there are unused bits between components (or before the first
component). A message is issued for each ``gap'' between
components. In addition, if a size clause is given for the type, the
rule will report if there are unused bits at the end of the component
(i.e. the size clause is bigger than the end of the last
component). Note that in the case of variant records, there can be
overlapping fields; the rule will control only the bits that belong to
no variant at all.
@item
``record'' controls record representation clauses.
@end itemize

In addition to these keyword, any specifiable attribute can be given
(including the initial ``'''); the rule will control specifications
of this attribute. Note that double attributes (like ``'CLASS'INPUT'')
can be given, and are considered different from the simple attribute
(``'INPUT''). It is of course possible to specify both.

Ex:
@example
All_Addresses: check representation_clauses (at, 'address);
All_Input: check representation_clauses ('input, 'class'input);
count representation_clauses ('SIZE);
@end example

@subsection Limitation
For the ``fractional_size'' and ``non_contiguous_record'' subrules,
there are some rare cases where AdaControl cannot evaluate the given
size or elements of the record representation clause, and thus not
detect the corresponding situation. Such cases are detected by the
rule ``uncheckable''. @xref{Uncheckable}.

@subsection Tip
Ada allows partial record representation clauses, i.e. it does not
require all fields to be specified. This means that if you add a field
to a record and forget to update the associated representation clause,
there will be no compilation error. The ``incomplete_record'' subrule
is handy for making sure that this does not happen.

@node Return_Type, Side_Effect_Parameters, Representation_Clauses, Rules Usage
@section Return_Type
@subsection Syntax
@example
<check|search|count> return_type [(<type_kind> @{, <type_kind>@})];
type_kind ::= class_wide          | unconstrained_discriminated |
              unconstrained_array | task | protected
@end example
@subsection Action
This rule controls functions whose return type belongs to one of the indicated type kinds:
@itemize @bullet
@item
@code{class_wide} controls class-wide types
@item
@code{unconstrained_discriminated} controls types with discriminants
(but not constrained subtypes of such types)
@item
@code{unconstrained_array} controls unconstrained array types
@item
@code{task} controls task types, or composite types that include tasks
as subcomponents.
@item
@code{protected} controls protected types, or composite types that include protected
objects as subcomponents.
@end itemize

If no type kind is specified, all type kinds are controlled. Note that
more than one kind may apply to a type: for example, a function can
return a class-wide type with discriminants that includes tasks and
protected objects as subcomponents. In this case, several messages are
issued for the same type.

Ex:
@example
check return_type (unconstrained_discriminated, unconstrained_array);
@end example

@subsection Limitations
There is a (very rare) case where AdaControl does not properly
recognize that a function returns a class-wide type. This is due to an
ASIS bug fixed in version 5.05, and therefore appears only with
earlier versions of the compiler. This happens when a generic unit
contains functions whose return type is a generic indefinite formal
type, and this generic is instantiated with a class-wide type.

@node Side_Effect_Parameters, Silent_Exceptions, Return_Type, Rules Usage
@section Side_Effect_Parameters
@subsection Syntax
@example
<check|search|count> Side_Effect_Parameters
   (<function name> @{, <function name>@});
@end example

@subsection Action
This rule controls subprogram calls or generic instantiations where
different actual parameters call functions known to have side
effects. This is dangerous practice, since correct behaviour may
depend on a certain evaluation order of parameters, which is not
specified by the language.

All functions mentionned as parameters in the rule are assumed to
interfere, i.e. the rule will signal if any of these functions is
called more than once in the parameters of a call.

It is allowed to give the name of a generic function, or of a function
declared in a generic package; in this case, all functions resulting
from instantiations of these generics will be considered.

In the case of renamings, you must give the name of the original
function; the rule will work correctly if the call is made through a
renaming of this function.

Ex:
@example
check side_effect_parameters (F1);
check side_effect_parameters (G1, G2);
@end example

Here, F1 has a side effect, and the rule will signal if it is called
more than once. G1 and G2 are assumed to interfere, and therefore the
rule will signal if either is called more than once, or if both are
called. However, having a call that mentions F1 and G2 is OK.

@subsection Limitation
Due to the size of internal structures, this rule may not be given
more than 100 times.

Due to an unimplemented feature of ASIS-for-Gnat, this rule will not
process defaulted parameters, and hence not detect interferences due
to calling a side-effect function through the default value.

@node Silent_Exceptions, Simplifiable_Expressions, Side_Effect_Parameters, Rules Usage
@section Silent_Exceptions
@subsection Syntax
@example
<check|search|count> Silent_Exceptions (<element> @{, <element>@});
element ::= <subprogram name> | raise | return | requeue
@end example

@subsection Action
This rule controls exception handlers that can cause exceptions to
silently disappear, i.e. handlers that do @i{not} call one of the
given subprograms (for example a reporting procedure) nor perform
other required operations, like returning, requeuing, or re-raising an
exception.

The parameters are the Ada callable constructs considered
``reporting''. In addition to subprogram and entry names, the special
names ``raise'', ``return'' and ``requeue'' mark raise statements,
return statements, and requeue statements (respectively) as
reporting. If a generic procedure or function is given to the rule,
then all corresponding instances are considered reporting
subprograms. If a generic package is given, any instantiation (in an
inner block of the handler) is considered reporting.

Note that the purpose of this rule is to require the reporting calls
to be ``eye-visible'', i.e. textually written in the exception
handler. For example, the rule will accept a call to a procedure
inside the sequence of statements of a package body declared in some
inner block; however, it will not accept the same call if it is in the
sequence of statements of a package instantiation (unless the generic
package is itself mentionned as reporting), because the call is not
``eye-visible''. For the same reason, a call to a reporting function
which happens as the default value of an omitted parameter in some
other call will not be accepted.

This rule can be given once for each of check, search and count. This
way, it is possible to have a level considered a warning (search), and
one considered an error (check).

Ex:
@example
check silent_exceptions (raise, reports.trace);
@end example

If the @code{@b{raise}} statements or subprogram calls appear only in
@code{@b{if}} or @code{@b{case}} statements, but not in all possible
paths, or if they appear only in the body of @code{@b{loop}}
statements, the rule will issue a message asking for a manual
verification, since it cannot be statically determined whether the
proper treatment happens in every case.

If ``raise'' is given as a parameter, the procedures
@code{Ada.Exceptions.Raise_Exception} and
@code{Ada.Exceptions.Reraise_Occurrence} are automatically added to
the list of procedures for both Check and Search, unless they are
explicitely specified as a parameter in a rule. This way, it is
possible to consider them as reporting procedures for Check (for
example) and not for Search.

@subsection Limitations
Currently, ``return'' includes all return statements. It would be nice
to separate function returns from procedure or accept returns. This is
expected to be done in the next version of AdaControl.

There are two cases that are not statically checkable, and
thus may not be identified by this rule: if an exception is raised in
an inner block statement and handled locally, and if the exception
handler aborts the current task.

If a reporting function is given, there are a few cases where the
calls will not be recognized:
@itemize @bullet
@item
inside a pragma
@item
in a representation clause
@item
in a code statement (i.e. as a field of a machine code instruction)
@end itemize
This limitation is intentional: these are such weird places to call a
reporting function that it seems better to draw attention to it...

@node Simplifiable_Expressions, Simplifiable_Statements, Silent_Exceptions, Rules Usage
@section Simplifiable_Expressions
@subsection Syntax
@example
<check|search|count> Simplifiable_Expressions
   [(<Expression_kw> @{, <Expression_kw>@})];

Expression_kw ::= range         | logical     | logical_true |
                  logical_false | parentheses | conversion
@end example

@subsection Action
This rule controls expressions that can be simplified in various ways,
depending on the indicated keyword:
@itemize @bullet
@item
``range'' controls expressions of the form @code{T'First .. T'Last}
that should be @code{T'range} (or even simply @code{T}).
@item
``logical_true'' controls redundant boolean expressions of the form
@code{<expr> = True} (or @code{/=}), and ``logical_false'' does the
same for comparisons with @code{false}. ``logical'' is the same as
specifying both ``logical_true'' and ``logical_false''.
@item
``parentheses'' controls unnecessary parentheses like those
surrounding the expression of an assignment, an ``if'' or a ``case''
statement, or those that are not required by operators precedence
rules.
@item
``conversion'' controls type conversions where the target subtype is
either the same as the expression's subtype, or the first named
subtype of the expression.
@end itemize
If no keyword is specified, the rule controls all kinds of
simplifiable expressions.

Ex:
@example
search simplifiable_expressions (parentheses);
check  simplifiable_expressions (range, logical);
@end example

@subsection Tips
There are cases where parentheses may seem unnecessary, but are
(purposedly) not reported by this rule. Consider for example:
@example
   X := A + (B + C);
@end example
Removing the parentheses would change the expression to mean:
@example
   X := (A + B) + C;
@end example
If the @code{"+"} operator has be redefined and is no more
associative, this would actually change the meaning of the program. In
a less contrieved example, note that:
@example
  X mod (A*B)
@end example
is @i{not} the same as:
@example
  X mod A * B
@end example
For these reasons, and to make the rule easier to understand for the
user, the rule does not report unnecessary parentheses between
operators of identical priority levels.

@node Simplifiable_Statements, Special_Comments, Simplifiable_Expressions, Rules Usage
@section Simplifiable_Statements
@subsection Syntax
@example
<check|search|count> Simplifiable_Statements [(<stmt_kw> @{, <stmt_kw>@})];
<stmt_kw> ::= block | handler     | if   | if_for_case |
              loop  | nested_path | null | dead
@end example
@subsection Action
This rule controls statements that can be removed or simplified in
various ways without changing the meaning of the program. Without
parameters, all kind of simplifiable statements are controlled;
otherwise, it depends on the provided keyword:
@itemize @bullet
@item
@code{block} controls block statements that have no labels, no
declarations, and no exception handlers.
@item
@code{handler} controls ``trivial'' exception handlers, i.e. handlers
whose sequence of statements includes only a single @code{@b{raise}}
statement without an exception name. However, a handler is not
reported if there is also a non trivial handler for @code{@b{others}}.
These examples show the situation:
@example
@b{exception}
   @b{when} Constraint_Error =>  -- Reported (no when others)
      @b{raise};
@b{end};

@b{exception}
   @b{when} Constraint_Error =>  -- Reported (trivial when others)
      @b{raise};
   @b{when} @b{others} =>        -- Reported
      @b{raise};
@b{end};

@b{exception}
   @b{when} Constraint_Error =>  -- Not reported (non trivial when others)
      @b{raise};
   @b{when} @b{others} =>
      Put_Line ("Error");
@b{end};
@end example
@item
@code{if} controls @code{@b{if}} statements with an @code{@b{else}}
part that contains only @code{@b{null}} statements (and can thus be
removed).
@item
@code{if_for_case} controls usage of @code{@b{if}} statements that
could be replaced by @code{@b{case}} statements. An  @code{@b{if}}
statement is assumed to be replaceable if it has at least one
@code{@b{elsif}} and all conditions are comparisons (or membership
tests, possibly connected by logical operators) of the same discrete
variable with static values. Typically, this subrule will spot
constructs like:
@example
   @b{if} X = 1 @b{then}
      ...
   @b{elsif} X = 2 or X = 3 or X = 4 @b{then}
      ...
   @b{elsif} X >= 5 and X <= 10 @b{then}
      ...
   @b{elsif} X in 11 .. 20 @b{then}
      ...
   @b{else}
      ...
   @b{end} @b{if};
@end example
@item
@code{nested_path} controls paths from @code{@b{if}} statements that
can be moved outside. This happens if the @code{@b{if}} has only
@code{@b{then}} and @code{@b{else}} paths, and either of them ends
with a ``breaking'' statement (@code{@b{raise}}, @code{@b{return}},
@code{@b{exit}} or @code{@b{goto}}); in this case, the other path
needs not be nested inside the @code{@b{if}} statement. However, if
both paths end with the @i{same} ``breaking'' statement, no error is
reported. In short, the rule signals the following examples:
@example
@b{if} Cond @b{then}
   @b{return};
@b{else}
   I := 1;
@b{end} @b{if};

@b{if} Cond @b{then}
   I := 1;
@b{else}
   @b{return};
@b{end} @b{if};
@end example
because they can be changed to:
@example
@b{if} Cond @b{then}
   @b{return};
@b{end} @b{if};
I := 1;

@b{if} @b{not} Cond @b{then}
   @b{return};
@b{end} @b{if};
I := 1;
@end example
The rule will not signal the following example, where both paths end
with the same ``breaking'' statement (@code{@b{return}}), because it
would break the symetry of the statement:
@example
@b{if} Cond @b{then}
   @b{return} 1;
@b{else}
   @b{return} 2;
@b{end} @b{if};
@end example
@item
@code{null} controls @code{@b{null}} statements that serve no purpose
and can be removed.  Note that if a @code{@b{null}} statement carries
a label, it is not considered  simplifiable.
@item
@code{loop} controls @code{while} loop statements where the condition
is a plain @code{True}, and can thus be changed to simple loops.
@item
@code{dead} controls dead code, i.e. statements that are statically
known to be never executed. This includes statements that follow a
@code{@b{return}}, @code{@b{requeue}}, or @code{@b{goto}} statement,
or an @code{@b{exit}} statement that is either unconditional or whose
condition is statically known to be true. It includes also
@code{@b{while}} statements and @code{@b{if}} statements (including
@code{@b{elsif}} paths) whose condition is statically false, and
@code{@b{for}} loops whose range is statically empty.
@end itemize

This rule can be given at most once for each value of the parameters.

Ex:
@example
check simplifiable_statements (block, null);
search simplifiable_statements (if);
@end example

@subsection Tips
@code{loop} may seem a strange thing to check, since no Ada
programmer is supposed to write this. However, experience shows that
it is a good indicator of code written by people who did not get
proper Ada training. Such code is certainly worth a peer review...

@node  Special_Comments, Statements, Simplifiable_Statements, Rules Usage
@section Special_Comments
@subsection Syntax
@example
<check|search|count> Special_Comments ("<pattern>" @{, "<pattern>"@});
@end example

@subsection Action
This rule controls comments that match one of the given patterns
(given as strings). Only the ``useful'' part of the comment is
matched against the patterns, i.e. the part after the ``@code{--}''
and spaces following it. Patterns are given using the full Regexp
syntax. @pxref{Syntax of regular expressions} for details. Pattern
matching is always case insensitive.

This rule is especially useful to find lines with comments like
``TBSL'' (To Be Supplied Later), which are often used to mark places
where something should be done before releasing the program.

Ex:
@example
check special_comments ("TBSL");

-- Report places where rules are disabled:
search special_comments ("##.* off");
@end example

@subsection Tips
Remember that a Regexp matches if the pattern matches any part of the
identifier.  Use ``^'' and ``$'' to match the beginning (resp. end) of
the comment, or both.

@subsection Limitations
This rule does not support wide characters outside the basic Latin-1 set.

@node Statements, Style, Special_Comments, Rules Usage
@section Statements
@subsection Syntax
@example
<check|search|count> statements (<statement_kw> @{, <statement_kw>@};

statement_kw ::=
   abort                  | accept_return         | assignment          |
   asynchronous_select    | block                 | case                |
   case_others            | case_others_null      | code                |
   conditional_entry_call | declare_block         | delay               |
   delay_until            | dispatching_call      | entry_return        |
   exception_others       | exception_others_null | exit                |
   exit_for_loop          | exit_while_loop       | for_loop            |
   function_return        | goto                  | if                  |
   labelled               | loop_return           | multiple_exits      |
   no_else                | null                  | procedure_return    |
   raise                  | raise_standard        | requeue             |
   reraise                | selective_accept      | simple_loop         |
   terminate              | timed_entry_call      | unconditional_exit  |
   unnamed_block          | unnamed_exit          | unnamed_loop_exited |
   unnamed_multiple_loop  | untyped_for           | while_loop
@end example

@subsection Action
This rule controls usage of certain Ada statements.
@itemize @bullet
@item
Statement keywords that are Ada keywords control the corresponding Ada
statements; note that @code{delay} will control only relative
@code{@b{delay}} statements (i.e. it will not control the @code{@b{delay
until}} statement).
@item
@code{accept_return} controls return statements that return from an
@code{@b{accept}} statement, @code{entry_return} controls return
statements that return from a (protected) entry body, and
@code{procedure_return} controls return statements that return from a
procedure. @code{loop_return} controls return statements that appear
inside a @code{@b{loop}} statement.
@item
@code{assignment} controls all assignment statements.
@item
@code{asynchronous_select} controls the @code{@b{select}}
... @code{@b{then abort}} statement. @code{conditional_entry_call}
controls the @code{@b{select}} ... @code{@b{else}}
statement. @code{timed_entry_call} controls the @code{@b{select}}
... @code{@b{or delay}} statement. @code{selective_accept} controls
the regular @code{@b{select}} statement.
@item
@code{block} controls all block statements, while @code{declare_block}
controls blocks with an explicit @code{@b{declare}} (even if the
declaration part is empty), and @code{unnamed_block} controls blocks
without a name.
@item
@code{case} controls all @code{case} statements.
@item
@code{case_others} controls any @code{@b{when others}} path in a
@code{@b{case}} statement, while @code{case_others_null} controls only
@code{@b{when others}} paths in a @code{@b{case}} statement that
contain only @code{@b{null}} statements.
@item
@code{code} controls code statements.
@item
@code{dispatching_call} controls all dispatching calls. Note that this
subrule controls dispatching procedure calls as well as dispatching
function calls, although the latter is technically an expression and
not a statement.
@item
@code{exit} controls all exit statements, while @code{exit_for_loop}
and @code{exit_while_loop} control @code{@b{exit}} statements that
terminate @code{@b{for}} and @code{@b{while}} loops,
respectively. @code{unconditional_exit} controls @code{@b{exit}}
statements without a @code{@b{when}} condition.  @code{multiple_exits}
controls loop that have more than one @code{@b{exit}} statement.
@code{unnamed_loop_exited} controls exit statements that terminate an
unnamed loop.
@item
@code{exception_others} controls any @code{@b{when others}} exception
handler, while @code{exception_others_null} controls only
@code{@b{when others}} exception handlers that contain only
@code{@b{null}} statements.
@item
@code{for_loop} controls all @code{for} loops.
@item
@code{function_return} controls return statements from
functions. Obviously, return statements cannot be forbidden in
functions; this keyword controls that there is only one return
statement in the body of functions, and at most one return statement
in each exception handler of the exception part of functions.
@item
@code{if} controls all @code{if} statements.
@item
@code{labelled} controls statements with a label (true statement
labels, not block and loop names).
@item
@code{no_else} controls @code{if} statements that have no @code{else}
path.
@item
@code{null} controls all @code{@b{null}} statements.
@item
@code{raise} controls all @code{@b{raise}} statements, while
@code{raise_standard} controls @code{raise} statements that raise one
of the predefined exceptions (those declared in package @code{Standard}) and
@code{reraise} controls only @code{@b{raise}} statements in exception
handlers that reraise the same exception. Note that @code{raise_standard}
and @code{reraise} take precedence over @code{raise} if they are mentionned
together, but that @code{raise} will control all form of @code{@b{raise}}
statements if no more specific subrule is given.
@item
@code{simple_loop} controls simple loops, i.e. those that are neither
@code{@b{while}} nor @code{@b{for}} loops.
@item
@code{unnamed_exit} controls @code{@b{exit}} statements without a
loop name that exits from a named loop.
@item
@code{unnamed_multiple_loop} controls nested loops that are not named
(i.e.  under this rule, only loops that contain no inner loop, and are
not nested in another loop, are allowed not to be named).  The kind of
loop (plain, @code{@b{for}}, @code{@b{while}}) is not considered.
@item
@code{untyped_for} controls @code{@b{for}} loops whose that uses a range
without an explicitely named type (i.e. @code{@b{for} I @b{in} 1..10 @b{loop}})
@item
@code{while_loop} controls all @code{@b{while}} loops.
@end itemize

Ex:
@example
search statements (delay);
check  statements (goto, abort);
check  statements (case_others_null, exception_others_null);
@end example

@subsection Tip
It may seem strange to control things like @code{@b{if}} or
@code{@b{case}} statements, since no coding standard would prohibit
their use. However, this may be useful, especially with ``count'', for
statistical purposes, like measuring the ratio of @code{@b{if}} to
@code{@b{case}} statements.

@node Style, Terminating_Tasks, Statements, Rules Usage
@section Style
@subsection Syntax
@example
<check|search|count> style;
<check|search|count> style (casing_attribute,  <casing_kw>);
<check|search|count> style (casing_identifier, <casing_kw>);
<check|search|count> style (casing_keyword,    <casing_kw>);
<check|search|count> style (casing_pragma,     <casing_kw>);
<check|search|count> style (compound_statement);
<check|search|count> style (default_in);
<check|search|count> style (exposed_literal, <type_kw>, @{, <value_place>@});
<check|search|count> style (multiple_elements @{,<element_kw>@});
<check|search|count> style (negative_condition);
<check|search|count> style (no_closing_name [, <max_lines>]);
<check|search|count> style (numeric_literal, [not] <base> [, <block_size>]);
<check|search|count> style (positional_association
                             @{,<context_kw> [,<max_allowed>]@}
                             | [, <max_allowed>]);
<check|search|count> style (renamed_entity);

casing_kw   ::= uppercase | lowercase | titlecase | original
context_kw  ::= pragma          | discriminant     | call | instantiation |
                array_aggregate | record_aggregate
element_kw  ::= [flexible] clause | declaration | statement
type_kw     ::= integer | real | character | string
value_place ::= <value> | <place>
value       ::= <integer number> | <real number> | "<pattern>"
place       ::= number | constant | var_init | repr_clause
@end example

@subsection Action
This rules controls usage of various Ada coding style. The first
parameter specifies which style aspect is to be checked:

@itemize @bullet
@item
``casing_attribute'', ``casing_keyword'', ``casing_identifier'', and
``casing_pragma'' control that attributes (respectively keywords,
identifiers, or pragmas) use the appropriate casing. ``original''
(which is allowed only for identifiers) means that identifiers must
use the same casing as in their declaration.
@item
``compound_statement'' controls that compound statements span at least
a minimum number of lines: 3 for @code{@b{if}} statements,
@code{@b{loop}} statements, block statements, and @code{@b{accept}}
statements with a body; 4 for @code{@b{case}} statements, selective
@code{@b{accept}} statements, and timed entry call statements; and 5
for conditional entry call statements and asynchronous select
statements.
@item
``default_in'' controls subprograms, entries and generics declarations
that omit an explicit @code{in} mode for a parameter.
@item
``exposed_literal'' controls the usage of literals (aka ``magic
values''), that appear outside of constants or named numbers
declarations. The second parameter tells to which kind of literals the
rule applies. The (optional) indicated values that follow are allowed
at any place; for strings, they are regular expressions. @xref{Syntax
of regular expressions}. Commonly allowed values are 0 and 1 for
integer literals, 1.0 and 0.0 for real literals and "^$" (the empty
string) for string literals. At most 20 values of each kind may be
specified. In addition, one or several <place> keyword can be used to
specify constructs where any literal is allowed: ``number'' stands for
named number declarations, ``constant'' for constant declarations,
``var_init'' for the initialization expression of variable
declarations, and ``repr_clause'' for representation clauses. If no
<place> is given, it is taken as @code{number, constant}, i.e. any
literal is allowed in named numbers and constant declarations.
@item
``multiple_elements'' controls clauses, declarations, and statements
that do not start on a line of their own (i.e. when there are more
than one of these on the same line). Extra parameters specify which
kind of element to check; if not specified, all kind of elements are
controlled. If ``flexible'' is specified in front of ``clause'' (not
allowed otherwise), it allows a @code{@b{use}} clause to be on the
same line as a @code{@b{with}} clause, provided all packages named in
the @code{@b{use}} clause are also named in the preceding
@code{@b{with}} clause.
@item
``negative_condition'' controls ``if'' statements with an ``else''
part and no ``elsif'', where the condition starts with a
@code{@b{not}}, and should therefore preferably be expressed
positively.
@item
``no_closing_name'' controls declarations, like package or subprograms,
that allow (but do not require) repeating the name at the end of the
declaration, and where the closing name is omitted (which is
considered bad style in general). However, it can be acceptable to
allow the omission of closing names for very short constructs;
therefore this rule has an optional parameter specifying the maximum
number of lines of a construct for which omitting the closing name is
allowed. This rule can be given only once for each of check, search
and count. This way, it is possible to have a length considered a
warning (search), and one considered an error (check). Of course, this
makes sense only if the length for search is less than the one for
check. If no length is specified, all occurrences of missing closing
names are signaled.
@item
``numeric_literal'' controls the presentation of numeric literals, depending
on the base (wich, as required by Ada rules, must be in the range
2..16). If ``not <base>'' is specified as the second parameter, the
given base may not be used for based literals. Otherwise, there must
be a third (integer) parameter to specify the size of blocks of digits
for that base, i.e. there must be an underscore character to separate
digits every <block_size> position. Typically, <block_size> is 3 for
base 10, 4 for base 2, etc.
@item
``positional_association'' controls pragmas, discriminants, calls,
aggregates, or instantiations that use positional associations.  Extra
parameters specify which kind of construct to check; if not specified,
all constructs are controlled. Each of the construct keywords is
optionally followed by an integer value; if it is specified, it gives
the maximum number of associations that are allowed to be positional,
i.e. the rule will trigger only if there are more than the indicated
number of associations. See examples below.

Note that for calls, positional association is @i{not} reported for
operators that use infix notation nor for calls to subprograms that
are attributes, since named notation is not allowed in these
cases. For calls, another rule controls positional associations
according to the value of parameters rather than their number:
@xref{Insufficient_Parameters}.
@item
``renamed_entity'' controls occurrences of identifiers within the scope
of a renaming declaration for them; i.e. it enforces that when an entity
has been renamed, the original name should not be used anymore.
@end itemize

Ex:
@example
search style (no_closing_name);
search style (no_closing_name, 5);
check style (casing_identifier, original);
check style (default_in);
check style (literal, 10, 3);
check style (exposed_literal, integer, 0, 1);
check style (exposed_literal, real, 0.0, 1.0);

 -- All positional associations:
check style (positional_association);

-- All positional associations in calls and aggregates:
check style (positional_association, aggregate, call);

 -- All positional associations with more than 3 elements:
search style (positional_association, 3);

-- Positional associations in calls with more than 3 elements,
-- and positional associations in aggregates with more than 4 elements:
search style (positional_association, call, 3, aggregate, 4);
@end example

Without parameter, the rule will control all style aspects with
parameter values that correspond to the most commonly used cases,
i.e. it is equivalent to the following:
@example
style (no_closing_name);
style (casing_attribute, titlecase);
style (casing_keyword, lowercase);
style (casing_identifier, original);
style (casing_pragma, titlecase);
style (positional_association);
style (default_in);
style (negative_condition)
style (multiple_elements)
style (literal, 10, 3);
style (exposed_literal, integer, 0, 1)
style (exposed_literal, real, 0.0, 1.0);
@end example

@subsection Tips
Note that operators always follow the casing rule for keywords, even
for calls that use the infix notation (i.e. in @code{"and"(A, B)}).

There are two kinds of calls where the rule does not complain about
usage of positional association: infix operator calls (since requiring
named notation would not allow infix notation any more), and calls to
subprograms that are attributes (since named notation is not allowed
for these).

In many cases, badly laid-out compound statements will trigger both the
``multiple_elements, statement'' and the ``compound_statement''
subrules. For example:
@example
@b{if} C @b{then} I := 1; @b{end} @b{if};
@end example
will complain that the assignment is on the same line as the
@code{@b{if}}, and that the @code{@b{if}} statement spans less than 3
lines. However, the subrules are not equivalent. For example,
@example
@b{if} C @b{then} I := 1;
@b{end}
@b{if};
@end example
will only find that the assignment is on the same line as the
@code{@b{if}}, while
@example
@b{if} C @b{then}
   I := 1; @b{end} @b{if};
@end example
will only find that the @code{@b{if}} statement spans less than 3
lines. In most cases, you'll want to specify both subrules to ensure
proper lay-out.

@subsection Limitations
If a predefined operator or an attribute is renamed, the
``renamed_entity'' subrule cannot check that the original entity is not
used in the scope of the renaming.  Such cases are
detected by the rule ``uncheckable''. @xref{Uncheckable}.

@node Terminating_Tasks, Uncheckable, Style, Rules Usage
@section Terminating_Tasks
@subsection Syntax
@example
<check|search|count> terminating_tasks
@end example
@subsection Action
This rule controls tasks that can terminate. A task is considered a
terminating task if its last statement is not an unconditional loop,
or this if this loop is exited. It is also considered terminating if
it contains a selective accept with a @code{@b{terminate}} alternative.

Since this rule has no parameters, it can be given only once.

Ex:
@example
check terminating_tasks
@end example

@subsection Tips
There is still one case where a task terminates, which is not reported
by this rule: when a task is aborted. This is intended, since there
are cases (like  mode changes) where a logically non-terminating task
is aborted.

If aborts are also to be reported, use the rule ``statements
(abort)''. @xref{Statements}.

@node Uncheckable, Units, Terminating_Tasks, Rules Usage
@section Uncheckable
@subsection Syntax
@example
<check|search|count> Uncheckable [(<risk_kw> [,<risk_kw>])];
<risk_kw> ::= false_positive | false_negative | missing_unit
@end example
@subsection Action
If the keyword ``missing_unit'' is given, this rule controls missing
units,  i.e. units not found (and therefore not controlled) will
result in an usual error message.

Otherwise, this rule controls constructs that are not static
and prevent other rules from being fully reliable. This rule is
special, since it really affects the way other rules behave when they
encounter a statically uncheckable construct. Therefore, if a label is
given, the message will include the label as usual, with an indication
of the rule that triggered the message; if no label is given, the
message will include the name of the rule that detected the
uncheckable construct, not ``uncheckable'' itself.

If the keyword ``false_negative'' is given, the rule will control
constructs that could result in false negatives, i.e. possible
violations that would go undected, while if the keyword
``false_positive'' is given, it will control constructs that could
result in false positives, i.e. error messages when the rule is not
really violated. If no keyword is given, both occurrences are
controlled.

This rule can be given only once for each of value of the parameters.

Ex:
@example
check uncheckable (false_negative);
search uncheckable (false_positive);
check uncheckable (missing_unit);
@end example

@subsection Tips
This rule is especially important when AdaControl is used in safety
critical software, since it will detect constructs that could escape
verification. Such constructs should be either disallowed, or require
manual inspection. On the other hand, in casual software, it may lead
to many messages, since for example dispatching calls are uncheckable
with many rules.

@subsection Limitation
With ``missing_unit'', the message does not include a reference to a
source location, since there is no place in the source which can be
considered as the origin of the error.  If you run AdaControl from
GPS, there will always be a separate category (``Uncheckable'') in the
locations window, under which the message will appear, with a file
name of ``none''. Don't try to click on the error message, since GPS
will find no file named ``none''!

@node Units, Unnecessary_Use_Clause, Uncheckable, Rules Usage
@section Units
@subsection Syntax
@example
<check|search|count> units [(<subrule> [,<subrule>])];
subrule ::= unreferenced | unchecked
@end example
@subsection Action
This rule controls that all necessary units, and only those, are
processed by AdaControl. If the keyword @code{unreferenced} is given,
the rule controls  compilation units that are part of the set of
analyzed units, but withed by no other unit. If the keyword
@code{unchecked} is given, the rule controls compilation units that
are withed by other unit(s), but not part of the set of controlled
units.

This rule can only be given once for each of the subrules.

Ex:
@example
check units (unchecked);
search units (unreferenced);
@end example

@subsection Tip
The main program will appear as unreferenced, since it is normally part of
the controlled units, and not withed by any other unit. As usual, the corresponding
message can be disabled by putting the comment:
@example
--## rule line off units
@end example
on the main program.

@node Unnecessary_Use_Clause, Unsafe_Paired_Calls, Units, Rules Usage
@section Unnecessary_Use_Clause
@subsection Syntax
@example
<check|search|count> unnecessary_use_clause [(<use kind> @{,<use kind>@})];
<use kind> ::= unused | qualified | operator | nested | movable
@end example

@subsection Action
This rule controls @code{@b{use}} clauses that do not serve any
purpose and can safely be removed, moved, or changed to a @code{@b{use
type}} clause. This happens in the following cases:
@itemize
@item
``unused'': a @code{@b{use}} clause is given, but no element from the
corresponding package is mentionned in its scope. The message starts
with ``unused:''.

In this case, the @code{@b{use}} clause can safely be removed.
@item
``qualified'': a @code{@b{use}} clause is given, but all elements from the
corresponding package are refered to using a qualified name
(i.e. prefixed by the name of the package). The message starts with
``all uses qualified:''.

In this case, the @code{@b{use}} clause can safely be removed, but you
may want to keep it for documentation purposes, since the package is
actually used within this scope.
@item
``operator'': a @code{@b{use}} clause is given, but the only elements that do not
use a qualified name are operators. The message starts with ``only
used for operators:''.

In this case, and except for some pathological cases (definition of
operators that are not primitive operations of the corresponding
type), the @code{@b{use}} clause can be replaced by one or several
@code{@b{use type}} clause(s).
@item
``nested'': a @code{@b{use}} clause is given within the scope of an enclosing
@code{@b{use}} clause for the same package. The message tells the
location of the other @code{@b{use}} clause.

If you also have a message that the outer @code{@b{use}} clause is
unnecessary, this means that all references to the package appear
inside the inner @code{@b{use}} clauses, and that the outer one can be
removed. If not, you can either remove the inner @code{@b{use}}
clauses, or remove the outer one and add more local @code{@b{use}}
clauses where necessary.
@item
``movable'': a @code{@b{use}} clause is given in a package specification, but all
uses are from the corresponding body. The message starts with ``use
clause can be moved to body:''.

In this case, the @code{@b{use}} clause can safely be moved to the
body, unless it appears in a library package, and there are
unqualified references to its elements from child units.
@end itemize

If no parameter is given, all cases are controlled, otherwise only
cases corresponding to the specified keyword(s) are controlled. This
rule can be given only once for each value of  the parameters.

Ex:
@example
remove: search unnecessary_use_clause (unused);
use_type: check unnecessary_use_clause (operator);
@end example

@subsection Tip
This rule checks only usage of @code{@b{use}} clauses. The rule
``reduceable_scope'' can be used to check that @code{@b{use}} clauses
do not span unnecessarily to wide a scope. @xref{Reduceable_Scope}.

@subsection Limitations
There are some rare cases where the rule may signal that a
@code{@b{use}} clause is not necessary, where it actually is. There is
no risk associated to this since if you remove the @code{@b{use}}
clause, the program will not compile.

The first one comes from a limitation of the ASIS standard: if the
@i{only} use of the @code{@b{use}} clause is for making the ``root''
definition of a dispatching call visible.

The second one comes from a limitation in ASIS-for-Gnat. This happens
when the @i{only} use of the @code{@b{use}} clause is for making an
implicitely declared operation (an operation which is declared by the
compiler as part of a type derivation) visible, and when:
@itemize
@item
the operation is the target of a renaming declaration;
@item
or the operation is passed as an actual to a generic instantiation;
@item
or all operands of the operation are universal (i.e. untyped).
@end itemize

Since these problems come from intrinsic limitations of ASIS, there is
nothing we can do about it. When this happens, you can disable the
unnecessary_use_clause rule using the line (or block) disabling
feature. @xref{Disabling rules}. Note that for the third alternative
of the second case, you can also qualify one of the parameters, so it
is not universal any more.

@node Unsafe_Paired_Calls, Unsafe_Unchecked_Conversion, Unnecessary_Use_Clause, Rules Usage
@section Unsafe_Paired_Calls
@subsection Syntax
@example
<check|search|count> unsafe_paired_calls
   (<Opening procedure>, <Closing procedure> [, <Lock type>]);
@end example

@subsection Action
This rule controls usage of calls to operations that are normally
paired (like P/V operations) and do not follow the "safe" pattern
defined below.  The following explanations are given in terms of
``locks'' since this is the primary use of this rule, however the rule
can be used for any calls that need to be properly paired.

The rule can deal with three different kinds of locks:
@itemize @bullet
@item
@i{abstract state machines}: There is no ``lock'' object, locking is
done directly inside the procedures. The <Lock type> parameter of the
rule must not be provided in that case.
@item
@i{object abstract data types}: The procedure operates on an object
(generally of a private type) representing the ``lock'' object, passed
as an ``in out'' parameter. The third parameter must be the
corresponding type, and the rule will control that all matching pairs of
calls refer statically to the same variable.
@item
@i{reference abstract data types}: The procedure operates on a
reference that designates the ``lock'' object, passed as an
``in''parameter. The third parameter must be the corresponding type,
which must be discrete or access, and the rule will control that all
matching pairs of calls refer statically to the same value (for
discrete types) or to the same constant  (for access types).
@end itemize

The "safe" pattern is defined as follows:
@itemize @bullet
@item
A call to the first procedure is the first statement of a
handled sequence of statements;
@item
A call to the second procedure is the last statement of the same
handled sequence of statements;
@item
Corresponding calls of a pair use the appropriate value for the
``lock'' parameter (if any), as explained above.
@item
There is no other call to either operation in the statements of the
handled sequence of statements, except in nested blocks or accept
statements; calls in such inner statements shall not reference the
same values or variables as outer ones.
@item
There is an exception handler for "others" in the
handled sequence of statements.
@item
Every exception handler of the handled sequence of statements includes
a single call to the second operation, using the appropriate value or
variable for the lock parameter.
@end itemize

Typically, the ``safe'' pattern corresponds to the following structures:
@example
-- Abstract state machine
@b{begin}
   P;
   -- Do something
   V;
@b{exception}
   @b{when} @b{others} =>
      V;
      -- handle exception
@b{end};

-- Object abstract data type
@b{declare}
   My_Lock : Lock_Type;
@b{begin}
   P (My_Lock);
   -- Do something
   V (My_Lock);
@b{exception}
   @b{when} @b{others} =>
      V (My_Lock);
      -- handle exception
@b{end};

-- Reference abstract data type
@b{declare}
   Lock_Ptr : @b{constant} Lock_Access := Get_Lock;
@b{begin}
   P (Lock_Ptr);
   -- Do something
   V (Lock_Ptr);
@b{exception}
   @b{when} @b{others} =>
      V (Lock_Ptr);
      -- handle exception
@b{end};
@end example

Ex:
@example
check unsafe_paired_calls (Semaphore.P, Semaphore.V, Semaphore.Lock_Access);
@end example

@subsection Tips
If the <Lock type> parameter is provided, both procedures must have a
single parameter of the given type, it must not correspond to an
``out'' parameter, and if it corresponds to an ``in'' parameter, the
type must be discrete or access.

This rule can be specified several times, and it is possible to have
the same procedure belonging to several rules. For example, if you
have a @code{Mask_Interrupt} procedure that should be matched by
either @code{Unmask_Interrupt} or @code{General_Reset} (all declared
in package @code{IT_Driver}), you can specify:
@example
check unsafe_paired_calls (IT_Driver.Mask_Interrupt,
                           IT_Driver.Unmask_Interrupt);
check unsafe_paired_calls (IT_Driver.Mask_Interrupt,
                           IT_Driver.General_Reset);
@end example

Normally, the legality of a rule is checked when the rules file is
parsed, and execution does not start if there is any error. However,
the legality of the provided type can be checked only during the
analysis. If the type is incorrect for some reason, a proper error
message is issued and execution stops immediately.

@subsection Limitation
Due to a weakness of the ASIS standard, dispatching calls  are not
considered. Especially, this means that the <Lock type> cannot be
class-wide.  Such calls are detected by the rule ``uncheckable''.
@xref{Uncheckable}.

Due to limitations of internal date structures, this rule can be
specified at most 32 times.

@node Unsafe_Unchecked_Conversion, Usage, Unsafe_Paired_Calls, Rules Usage
@section Unsafe_Unchecked_Conversion
@subsection Syntax
@example
<check|search|count> unsafe_unchecked_conversion
@end example
@subsection Action
This rule controls instances of @code{Unchecked_Conversion} between
types where the following conditions are not met:
@itemize @bullet
@item
A size clause has been specified for both types
@item
Both sizes are equal
@end itemize

Moreover, a special message is given if any of the types is a class-wide
type (certainly a very questionable construct!).

Ex:
@example
check unsafe_unchecked_conversion
@end example

@subsection Limitation
There are cases where a size clause is given for a type, but
AdaControl is unable to evaluate it.  This happens especially if the
size clause refers to a size attribute of a predefined type, like:
@example
@b{for} T'Size @b{use} Integer'size;
@end example

This can lead to false positives (i.e. detection of instantiations of
@code{Unchecked_Conversion} that are actually OK. Such cases are
detected by the rule ``uncheckable''. @xref{Uncheckable}.

@node  Usage, Use_Clauses, Unsafe_Unchecked_Conversion, Rules Usage
@section Usage
@subsection Syntax
@example
<check|search|count> usage
   (variable|object @{,[not] from_spec | read | written | initialized@});
<check|search|count> usage
   (constant @{,[not] from_spec | read@});
<check|search|count> usage
   (exception @{,[not] from_spec | raised | handled@});
<check|search|count> usage
   (task @{,[not] from_spec | called | aborted@});
<check|search|count> usage
   (protected @{,[not] from_spec | called@});
<check|search|count> usage
   (all [,[not] from_spec]);
@end example

@subsection Action
This rule controls how certain entitities (variables, constants,
exceptions, tasks and protected objects) are used. The first parameter
defines the class of entities to be controlled (``object'' stands for
both ``constant'' and ``variable'', and ``all'' stands for all
classes). If only one parameter is given, usage of all entities
belonging to the indicated class are reported . Otherwise, other
parameter(s) are keyword that restrict the kind of usage being
controlled.

``[not] from_spec'' restrict entities being checked to those that
appear in (generic) package specifications.  Other keywords carry
their obvious meaning, and are allowed only where appropriate. The
rule will output the information only for objects that match all the
conditions given. A combination of parameters can be given only once
for each of ``check'', ``search'', and ``count''.

The report includes the kind of unit that declares the entity (normal
unit, instantiation, or generic unit) and whether the entity is known
to be initialized, read, written, raised, handled, called, or aborted,
depending on the entity's class. Some combinations give an extra
useful message (for example, a variable which is initialized and read
but not written will produce a ``could be declared constant'' message).

Variables of an access type and variables of an array type whose
components are of an access type (or arrays of an access type, etc.)
are always considered initialized, since they are initialized to
@code{null} by the compiler.

Variables that cannot be assigned to (i.e. variables of an array type
with some null dimension, or variables of a discrete type whose range
includes no values) are specially recognized as ``pseudo-constants'':
there is no message that they are not written to (since it is not
possible), but there is an indication that they are pseudo-constants.

Exceptions raised by calling @code{Raise_Exception} and tasks aborted by
calling @code{Abort_Task} are properly recognized as exceptions begin
raised and tasks being aborted, respectively.

In the case of entities declared in generic packages, the rule will
report on usage of the entities for each instantiation, as well as on
global usage for the generic itself. Usage for an instantiation will
include usage in the generic itself (i.e. if the generic writes to a
variable, the variable will be marked as ``written'' for each
instantiation). Usage for the generic itself is the union of all
usages in all instantiations (i.e., if a variable from any
instantiation is written to, the variable from the generic will be
marked as written). Therefore, if the rule reports that a variable in
a generic package can be declared constant, it means that no instance
of this variable from any instantiation is being written to. But bear
in mind that this can be trusted only if all units from the program
are analyzed. @xref{limitation}.

Note that usage of entities whose declaration is not processed (like,
typically, elements declared in standard packages like
@code{Ada.Text_IO}), is not reported.

Ex:
@example
-- No variable in package spec; check usage otherwise
Package_Variable: check usage  (variable, from_spec);
Constantable    : search usage (variable, not from_spec, read,
                                          initialized, not written);
Uninitialized   : check usage  (variable, not from_spec, read,
                                          not initialized, not written);
Removable       : search usage (object,   not from_spec, not read);

check usage (exception, not raised);
check usage (task,      aborted);
check usage (protected, not called);
count usage (task);
@end example

@subsection Tips
Constants that are never used, exceptions that are never raised or
handled, tasks that are never called, etc. are suspicious. Moreover,
some useful compiler warnings (like those about variables that should
be declared constants) are not output for variables declared in
library packages, and even in some other contexts (at least with
GNAT). This rule can check these kind of things, project wide.

Some of these checks make sense only for entities declared in package
specifications; for example, variables are often discouraged in
package specifications, or need at least some extra control. That's
why it can be useful to restrict some checks to package specifications.

Note that an unspecified parameter in a rule stands for two rules
(positive and negative form of the missing parameter). I.e.:
@example
search usage (variable, from_spec, read, written);
@end example
is the same as:
@example
search usage (variable, from_spec, read, written, initialized);
search usage (variable, from_spec, read, written, not initialized);
@end example
Therefore, the following example will complain on the second line that
the rule has already been given for this combination of parameters:
@example
search usage (variable, from_spec, read, written);
search usage (variable, from_spec, read, written, not initialized);
@end example

Note that the notion of constants for this rule includes named numbers.

@anchor{limitation}
@subsection Limitations
The report of this rule is output at the end of the run, and is
meaningful only for the units that have been processed; i.e., if it
reports ``variable not read'', it should be understood as ``not read
by the units given''. In order to have meaningful results, it is
therefore advisable to use this rule on the complete closure of the
program.

An exception can be raised by passing its @code{'Identity} to a
procedure that will in turn call @code{Raise_Exception} (and similarly
for @code{Abort_Task}). These cases are not statically determinable,
and therefore not recognized by AdaControl. However, these cases can
be identified by searching the use of the @code{'Identity} attribute
with the following rule:
@example
check entity (all 'Identity);
@end example

If an object is the prefix of a @code{'Access},
@code{'Unchecked_Access}, or @code{'Address} attribute, it can be used
through the access (or address) value in ways that are not statically
analyzable. The same happens if objects are targets of dynamic
renamings. Such cases are detected by the rule
``uncheckable''. @xref{Uncheckable}.

Due to a weakness of the ASIS standard, usages of variables used as
parameters to dispatching calls are ignored. This limitation will be
removed as soon as we find a way to work around this problem, but the
issue is quite difficult!

@node Use_Clauses, With_Clauses, Usage, Rules Usage
@section Use_Clauses
@subsection Syntax
@example
<check|search|count> use_clauses
   [([<locality>,] <package name> @{, <package name>@})];
<locality> ::= local | global
@end example

@subsection Action
This rule controls usage of use clauses, @i{except} for the ones that
name one of the mentioned packages. It is therefore possible to allow
@code{@b{use}} clauses just for certain packages. If the keyword
``global'' is given, only @code{@b{use}} clauses that appear in
context clauses (i.e. together with the @code{@b{with}} clauses) are
controlled; if the keyword ``local'' is given, only @code{@b{use}}
clauses that appear as declarations are controlled. If no ``local'' or
``global'' is given, all @code{@b{use}} clauses are controlled.

This rule can be given at most once for each of check, search and
count. This way, it is possible to have a level considered a warning
(search), and one considered an error (check).

Ex:
@example
-- Global use clauses are disallowed, local ones only for IO:
check use_clauses (global);
check use_clauses (local, Ada.Text_IO, Ada.Wide_Text_IO);
@end example

@node With_Clauses,  , Use_Clauses, Rules Usage
@section With_Clauses
@subsection Syntax
@example
<check|search|count> with_clauses [(<with_kw> [, <with_kw>])];
with_kw ::= multiple_names | reduceable | inherited
@end example
@subsection Action
This rule controls @code{@b{with}} clauses that should be removed or
moved to a better place. Each of the keywords can be given at most
once. If no keyword is given, both @code{reduceable} and
@code{inherited} are assumed.

If the keyword @code{multiple_names} is given, the rule will report on
any @code{@b{with}} clause that mentions more than one unit name.

If the keyword @code{reduceable} is given, the rule will report:
@itemize @bullet
@item
Redundant @code{@b{with}} clauses, i.e. clauses given more than once
for the same unit. This includes the case where the same
@code{@b{with}} clause is given in a specification and the
corresponding body, and the case of renamings of a same unit
(i.e. @code{Text_IO} and @code{Ada.Text_IO}). Note that giving a
@code{@b{with}} clause in a unit, and repeating it in a child unit (or
subunit) is @i{not} considered redundant.
@item
Unused @code{@b{with}} clauses, i.e. when nothing from the withed unit
is referenced in the corresponding unit. Use of a package name in a
@code{@b{use}} clause is @i{not} considered a usage of the
package. The rule signals when a withed unit is not used in a unit,
but used in one or more of its subunits. If an unused @code{@b{with}}
clause is given on a package specification, the message reminds that
it migh be useful for child units.
@item
Moveable @code{@b{with}} clauses, i.e. when the withed unit is not
used in the specification, but only in the body, and should be moved
to the body.
@end itemize

If the keyword @code{inherited} is given, the rule will report when  a
child unit or a subunit uses a unit which is not directly withed,
i.e. when withed only from a parent (or enclosing) unit. Although Ada
rules imply that a @code{@b{with}} clause carries on to child units
and subunits, it can be considered better practice to ensure that
every compilation unit withes directly the units it needs.

Ex:
@example
check with_clauses (multiple_names, reduceable);
search with_clauses (inherited);
@end example

@subsection Tips
A @code{@b{with}} clause can safely be removed if it is unused, and no
child unit (or subunit) reports that the unit is inherited.

@node Examples of using AdaControl for common programming rules, Non upward-compatible changes, Rules Usage, Top
@chapter Examples of using AdaControl for common programming rules

In most projects, there are @i{programming rules} that define the way
a program should be written. AdaControl performs checks, i.e. it finds
occurrences of certain kinds of constructs. In this chapter, we give
examples of commonly found programming rules, and how the corresponding
checks can be written.

@menu
* Rules files provided with AdaControl::  
* Automatically checkable rules::  
* Rules that need manual inspection::  
@end menu

@node Rules files provided with AdaControl, Automatically checkable rules, Examples of using AdaControl for common programming rules, Examples of using AdaControl for common programming rules
@section Rules files provided with AdaControl
The @code{rules} directory provides rules files that can be sourced to
enforce some commonly encountered general rules.

@rule{Identifiers from Standard shall not be redefined}

Use file @code{no_standard_entity.aru}.

@rule{Identifiers from System shall not be redefined}

Use file @code{no_system_entity.aru}.

@rule{Predefined IO packages shall not be used}

Use File @code{no_io.aru}.

@rule{Standard package XXX shall not be used}

File @code{no_standard_unit.aru} controls usage of @i{all} standard
packages. Comment out those that you do want to allow.

@rule{Obsolescent features shall not be used}

Use file @code{no_obsolescent_features.aru}. Not all obsolescent features are
controlled, but most of them (those that are most worth checking) are.

@rule{Gnat specific attributes shall not be used}

Use file @code{no_gnat_attribute.aru}

@rule{Features from annex X shall not be used}

Use file @code{no_annex_X.aru}.

@rule{The Ravenscar profile shall be enforced}

Use file @code{ravenscar.aru}.

Note that not all of the restrictions of the Ravenscar profile are
currently controlled, but many are, and we expect later releases of
AdaControl to increase the number of controlled features. In some
cases (like ``Detect_Blocking''),  AdaControl does a better job than
the profile, since it can detect statically situations that the
profile only requires to be detected at run-time. The rule file is
also slightly more restrictive than the profile; for example, the
restriction ``no_task_allocation'' only disallows task allocators,
while this rule file controls the declaration of access types on tasks.

@rule{NASA coding guidelines shall be enforced}

Use file @code{nasa.aru}. This file is an example of how to convert guidelines (available from @uref{http://fsw.gsfc.nasa.gov/gds/code_standards_ada.pdf}) into an AdaControl rules file.

@rule{New reserved words of Ada 2005 shall not be used}

Use file @code{reserved_2005.aru}.

@node Automatically checkable rules, Rules that need manual inspection, Rules files provided with AdaControl, Examples of using AdaControl for common programming rules
@section Automatically checkable rules
Below are examples of rules that can be directly checked by AdaControl.

@rule{Goto statement shall not be used}
@example
check statements (goto);
@end example

@rule{Short circuit forms should be preferred over corresponding logical operators}
@example
Use_Short_Circuit: search expressions (and, or);
@end example

@rule{Aggregates should be used for full assignments to structured variables, unless it is a record with a single component}
@example
check multiple_assignments (groupable, given 2, ratio 100);
@end example

@rule{All loops that contain exit statements must be named, and the name must be given in the exit statement}
@example
check statements (unnamed_loop_exited);
check statements (unnamed_exit);
@end example

@rule{All type names must start with ``T_''}
@example
check naming_convention (type, "^T_");
@end example

@rule{All program units must repeat their name after the ``end''}
@example
check style (no_closing_name);
@end example

@rule{Pragma Suppress is not allowed}
@example
check pragmas (suppress);
@end example

@rule{Ada tasking must not be used}
@example
check declarations (task);
@end example

@rule{``='' and ``/='' shall not be used between real types}
@example
check expressions (real_equality);
@end example

@rule{All tasks must provide an exception handler that calls ``Failure'' in
the case of an unhandled exception}
@example
check exception_propagation (task);
check silent_exceptions (failure);
@end example

@rule{Unchecked_Conversion shall not be used}
@example
check entities (ada.unchecked_conversion);
@end example

@rule{No global variable shall be declared in the visible part of a package
specification}
@example
check usage (variable, from_spec);
@end example

@rule{Predefined numeric types of the language shall not be used}
@example
check entities (standard.Integer,
                standard.short_integer,
                standard.long_integer,
                standard.Float,
                standard.short_float,
                standard.long_float);
@end example

@rule{Access to subprograms shall not be used}
@example
check declarations (access_to_sp);
@end example

@rule{Abort statements shall not be used}
@example
check statements (abort);
@end example

@rule{There shall be only one instantiation of
Ada.Numerics.Generic_Elementary_Functions for each floating point type}
@example
-- Put a --##RULE LINE OFF GEF
-- for the one which is allowed
GEF: check Instantiations (Ada.Numerics.Generic_Elementary_Functions);
@end example

@rule{A local item shall not hide an outer one with the same name}
@example
check Local_Hiding;
@end example

@rule{There shall be no IOs in exception handlers}
@example
check entity_inside_exception (ada.Text_IO.put, ada.Text_IO.put_line,
                               ada.Text_IO.get, ada.Text_IO.get_line);
@end example
Note that this checks for all overloaded procedures, but only those
dealing with characters and strings (those defined directly within
Ada.Text_IO). If the names ``get'' and ``put'' are not used for
anything else than IOs, a more general form can be given as:
@example
check entity_inside_exception (all get,      all put,
                               all get_line, all put_line);
@end example
This will check that no entity with the corresponding names appear in
exception handlers.

@rule{Exceptions shall not be used}
@example
No_Exception: check declarations (exception, handlers);
No_Exception: check statements (raise);
No_Exception: check entities (Ada.Exceptions);
@end example

This will check that no exception is declared, no exception handler is
provided, and no exception is raised, not even through the services of
the package @code{Ada.Exceptions}.

@rule{No procedure exported to C shall propagate exceptions}
@example
check exception_propagation (interface, C);
@end example

@rule{There shall be no Unchecked_Conversion to or from Address}
@example
check instantiations (ada.unchecked_conversion, system.address);
check instantiations (ada.unchecked_conversion, <>, system.address);
@end example

@rule{There shall be no use clause except for Text_IO}
@example
check use_clauses(ada.text_IO);
@end example

@rule{Use explicit list of values in case statements rather than ``when others''if the ``when others'' would cover less than 10 values}
@example
check Case_Statement(min_others_span, 10);
@end example

@rule{If a block is more than 20 lines long, it must be named}
@example
check Max_Size(unnamed_block, 20);
@end example

@rule{Exceptions shall not be handled except by main program}
@example
check declaration (handlers)
@end example
This check will be disabled for the exception handler of the main program.

@rule{Each unit has a header starting with a fixed format, and must contain at least 10 lines of comments}
@example
check header_comments (model, "header.txt");
check header_comments (minimum, 10);
@end example
The file @code{header.txt} contains the required header (as regexps), like:
@example
^--*@{50@}$
^-- This is a header$
@end example

@node Rules that need manual inspection,  , Automatically checkable rules, Examples of using AdaControl for common programming rules
@section Rules that need manual inspection
Below are examples of rules that require manual inspection, but where
AdaControl can be used to identify suspicious areas.

@rule{All usages of the 'ADDRESS attribute shall be justified and documented}
@example
search entities (all 'address);
@end example

@rule{Specifying an address for a variable shall be restricted to hardware interfacing}
@example
search representation_clauses(address);
@end example

@rule{There shall be no memory leakage}
@example
search Allocators;
@end example
This rule identifies all allocations, and thus can be used to check
that all allocated elements are properly deallocated.

@node  Non upward-compatible changes, Syntax of regular expressions, Examples of using AdaControl for common programming rules, Top
@chapter Non upward-compatible changes
This chapter is intended to users of a previous version of AdaControl,
who want to migrate rule files to the latest version. Although we
understand the burden of non upward-compatible changes, we consider
that making AdaControl more powerful and easier to use is sometimes
more important than strict compatibility. Moreover, in most cases the
changes are very straightforward and can be done easily by hand, or
with scripts if many files are involved.

@section Migrating from 1.6r8
@subsection ``message'' command
The message is now syntactically a string, and must always be enclosed
in double quotes (quotes were optional in previous versions).

@subsection ``source'' command
If a ``source'' command is given in a rules file, and the sourced file
is given with a relative path, it is interpreted relatively to the
sourcing file (it was interpreted relatively to the current directory
previously). This should make ``chained'' sourcing easier, since the
interpretation does not depend on where the sourcing file is being
called from.

@subsection Control_Characters
This rule is now called ``Characters'' and can process other kinds of
characters in addition to control characters.  Control characters
correspond to the ``control'' parameter of the rule. Change:
@example
check control_characters;
@end example
to:
@example
check characters (control);
@end example

@subsection If_For_Case
This rule is has been changed into a subrule of the (new) rule
``simplifiable_statements''.  Change:
@example
check if_for_case;
@end example
to:
@example
check simplifiable_statements (if_for_case);
@end example

@subsection Instantiations
The rule does not print the number of instantiations any more, since the same
effect can be achieved with the ``count'' rule type.

@subsection Local_Instantiation
This rule has been removed, since its effect can now be achieved with other rules:
the rule ``declarations'' to check for local instantiations of any generic, and the rule
``instantiations'' to check for local instantiations of specified generics.
Change:
@example
R1: check Local_Instantiation;
R2: search Local_Instantiation (Ada.Unchecked_Conversion);
@end example
to:
@example
R1: check  declarations   (local instantiation);
R2: search Instantiations (local Ada.Unchecked_Conversion);
@end example

@subsection Naming_Convention
Quotes are no more optional around patterns.

The <location> modifier is now before the <filter_kind> (it was before the
pattern previously). This may require splitting the rule in two in some cases.
For example, change:
@example
check naming_convention (object, local "^L_", global "^G_");
@end example
to:
@example
check naming_convention (local object, "^L_");
check naming_convention (global object, "^G_");
@end example

@subsection No_Safe_Initialization
The name of this rule has been changed to ``improper_initialization'',
since it now controls other cases of improper initialization.

@subsection Special_Comments
Quotes are no more optional around patterns.

@subsection Statements
Two subrules of this rule have migrated to the new rule
``simplifiable_statements'' (with slightly different names). Change:
@example
check statements (unnecessary_null);
check statements (while_true);
@end example
to:
@example
check simplifiable_statements (null);
check simplifiable_statements (loop);
@end example

@section Migrating from 1.5r24
@subsection Declarations
The subrule ``Formal_In_Out'' has been renamed as
``In_Out_Generic_Parameter'', for consistency with the new
``In_Out_Parameter'' subrule.

The subrules ``renames'' and ``not_operator_renames'' have been renamed
to ``renaming'' and ``not_operator_renaming''.

As a consequence of being able to specify the location of any
construct, the subrules ``nested_function_instantiation'',
``nested_generic_function'', ``nested_generic_package'',
``nested_generic_procedure'', ``nested_package'',
``nested_package_instantiation'', and
``nested_procedure_instantiation'' have been removed and replaced with
the corresponding general construct (without ``nested_''). You can
have the same effect by specifying the ``nested'' modifier in front of
them. I.e., change:
@example
check declarations (nested_generic_function);
@end example
to:
@example
check declarations (nested generic_function);
@end example

@subsection Naming_Convention
The <Location> keyword is placed before the <Filter_Kind> keyword instead of
before the <Pattern>, which looks more natural. The ``Any'' keyword has been removed,
since omitting the <Location> keyword has the same effect. Change:
@example
check naming_convention (variable, global "^G_");
check naming_convention (package, any "^Pack_");
@end example
to:
@example
check naming_convention (global variable, "^G_");
check naming_convention (package, "^Pack_");
@end example

@subsection Non_Static_Constraint
This rule is now called Non_Static, since it is no more restricted to
constraints. The parameters ``index'' and ``discriminant'' have been
changed to ``index_constraint'' and ``discriminant_constraint'',
respectively. Change:
@example
check non_static_constraint (index, discriminant);
@end example
to:
@example
check non_static (index_constraint, discriminant_constraint);
@end example

@subsection Positional_Parameters
This rule has been renamed to @code{Insufficient_Parameters}, since it does no more
handle the ``maximum'' subrule. Controlling positional parameters according to their number
is now done by the rule @code{style (positional_association)}. Change:
@example
check positional_parameters (maximum, 3);
check positional_parameters (insufficient, 2, Boolean);
@end example
to:
@example
check style (positional_association, call, 3);
check insufficient_parameters (2, Boolean);
@end example

@subsection Real_Operator
This rule is no more a rule of its own, it is a subrule of the (new)
rule Expressions, whose name is Real_Equality. Change:
@example
check Real_Operators;
@end example
to:
@example
check expressions (Real_Equality);
@end example

@subsection Style
The name of the subrule ``casing'' has been changed to
``casing_identifier'' since the casing of attributes and pragmas can
now also be checked. The casing style is no more optional.

The name of the subrule ``literal'' has been changed to
``numeric_literal'' (since characters and strings are also literals,
but are not handled by this subrule).

The subrule ``exposed_literal'' now requires an extra parameter to
tell whether it applies to integer literals, real literals, character
literals or string literals.  Allowed values are provided after this
parameter, and must of course be of the appropriate type. In short, if
you had:
@example
check style (exposed_literal, 0, 1, 0.0, 1.0);
@end example
you must change it to:
@example
check style (exposed_literal, integer, 0, 1)
check style (exposed_literal, real, 0.0, 1.0);
@end example

The ``aggregate'' parameter of the subrule ``positional_association''
has been split into ``array_aggregate'' and ``record_aggregate''. For example,
change:
@example
check style (positional_association, aggregate);
@end example
into:
@example
check style (positional_association, record_aggregate, array_aggregate);
@end example


@section Migrating from 1.4r20
@subsection GPS integration
The XML file used to describe AdaControl features to GPS used to be
called @code{adactl.xml}. It is now called @code{zadactl.xml}, since
GPS processes its initialization files in alphabetical order. This
avoids shuffling the menus when AdaControl support is activated.

Make sure to remove the old @code{adactl.xml} file from the GPS
plug-ins directory before installing the new version.

@subsection Declarations
The parameters ``access'' and ``access_subprogram'' have been changed
to ``access_type'' and ``access_subprogram_type'', for consistency
with the new parameters.

@subsection Header_Comments
A keyword has been added to specify the required number of comment lines.
Change:
@example
check Header_Comments (10);
@end example
to:
@example
check Header_Comments (minimum, 10);
@end example

@subsection No_Closing_Name
This rule is now part of the ``style'' rule. Change:
@example
check|search|count No_Closing_Name;
@end example
to:
@example
check|search|count Style (No_Closing_Name);
@end example

@subsection Specification_Objects
This rule is now part of the ``usage'' rule. Change:
@example
check|search|count Specification_Objects (<parameters>);
@end example
to:
@example
check|search|count Usage (Object, From_Spec, <parameters>);
@end example

@subsection Statement
Name changed from ``statement'' to ``statements'' (added an 's'), to
be consistent with other rules.

@subsection When_Others_Null
This rule is now part of the ``statements'' rule. Change:
@example
check|search|count When_Others_Null (case);
check|search|count When_Others_Null (exception);
@end example
to:
@example
check|search|count Statements (case_others_null);
check|search|count Statements (exception_others_null);
@end example

@node Syntax of regular expressions,  , Non upward-compatible changes, Top
@chapter Syntax of regular expressions
The following syntax gives the complete definition of regular
expressions, as used by several rules.  It is taken from the
specification of the package @code{gnat.regpat}, where additional
information is available.

@example
regexp ::= expr
       ::= ^ expr               -- anchor at the beginning of string
       ::= expr $               -- anchor at the end of string

expr   ::= term
       ::= term | term          -- alternation (term or term ...)

term   ::= item
       ::= item item ...        -- concatenation (item then item)

item   ::= elmt                 -- match elmt
       ::= elmt *               -- zero or more elmt's
       ::= elmt +               -- one or more elmt's
       ::= elmt ?               -- matches elmt or nothing
       ::= elmt *?              -- zero or more times, minimum number
       ::= elmt +?              -- one or more times, minimum number
       ::= elmt ??              -- zero or one time, minimum number
       ::= elmt @{ num @}         -- matches elmt exactly num times
       ::= elmt @{ num , @}       -- matches elmt at least num times
       ::= elmt @{ num , num2 @}  -- matches between num and num2 times
       ::= elmt @{ num @}?        -- matches elmt exactly num times
       ::= elmt @{ num , @}?      -- matches elmt at least num times
                                   non-greedy version
       ::= elmt @{ num , num2 @}? -- matches between num and num2 times
                                   non-greedy version

elmt   ::= nchr                 -- matches given character
       ::= [range range ...]    -- matches any character listed
       ::= [^ range range ...]  -- matches any character not listed
       ::= .                    -- matches any single character
                                -- except newlines
       ::= ( expr )             -- parens used for grouping
       ::= \ num                -- reference to num-th parenthesis

range  ::= char - char          -- matches chars in given range
       ::= nchr
       ::= [: posix :]          -- any character in the POSIX range
       ::= [:^ posix :]         -- not in the POSIX range

posix  ::= alnum                -- alphanumeric characters
       ::= alpha                -- alphabetic characters
       ::= ascii                -- ascii characters (0 .. 127)
       ::= cntrl                -- control chars (0..31, 127..159)
       ::= digit                -- digits ('0' .. '9')
       ::= graph                -- graphic chars (32..126, 160..255)
       ::= lower                -- lower case characters
       ::= print                -- printable characters (32..127)
       ::= punct                -- printable, except alphanumeric
       ::= space                -- space characters
       ::= upper                -- upper case characters
       ::= word                 -- alphanumeric characters
       ::= xdigit               -- hexadecimal chars (0..9, a..f)

char   ::= any character, including special characters
           ASCII.NUL is not supported.

nchr   ::= any character except \()[].*+?^ or \char to match char
           \n means a newline (ASCII.LF)
           \t means a tab (ASCII.HT)
           \r means a return (ASCII.CR)
           \b matches the empty string at the beginning or end of a
              word. A word is defined as a set of alphanumerical
              characters (see \w below).
           \B matches the empty string only when *not* at the
              beginning or end of a word.
           \d matches any digit character ([0-9])
           \D matches any non digit character ([^0-9])
           \s matches any white space character. This is equivalent
              to [ \t\n\r\f\v]  (tab, form-feed, vertical-tab,...
           \S matches any non-white space character.
           \w matches any alphanumeric character or underscore.
              This include accented letters, as defined in the
              package Ada.Characters.Handling.
           \W matches any non-alphanumeric character.
           \A match the empty string only at the beginning of the
              string, whatever flags are used for Compile (the
              behavior of ^ can change, see Regexp_Flags below).
           \G match the empty string only at the end of the
              string, whatever flags are used for Compile (the
              behavior of $ can change, see Regexp_Flags below).
...    ::= is used to indication repetition (one or more terms)
@end example

Embedded newlines are not matched by the ^ operator.  It is possible
to retrieve the substring matched a parenthesis expression. Although
the depth of parenthesis is not limited in the regexp, only the first
9 substrings can be retrieved.

The operators '*', '+', '?' and '@{@}' always match the longest possible
substring. They all have a non-greedy version (with an extra ? after
the operator), which matches the shortest possible substring.

For instance:
@example
 regexp="<.*>"   string="<h1>title</h1>"   matches="<h1>title</h1>"
 regexp="<.*?>"  string="<h1>title</h1>"   matches="<h1>"
@end example

'@{' and '@}' are only considered as special characters if they appear
in a substring that looks exactly like '@{n@}', '@{n,m@}' or '@{n,@}', where
n and m are digits. No space is allowed. In other contexts, the curly
braces will simply be treated as normal characters.

Note that if you compiled AdaControl with the
@code{String_Matching_Portable} package, only basic wildcards are
available, i.e. only ``*'' and ``?'' are supported, where ``*''
matches any string of character and ``?'' matches a single character.
@bye
