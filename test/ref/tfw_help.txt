Rule: ABNORMAL_FUNCTION_RETURN
Control functions that can propagate Program_Error due to not executing a return statement

Parameter(s): none
----
Rule: ALLOCATORS
Control occurrences of allocators, either all of them,
or just those for specific type(s) or types belonging
to the indicated categories, or just those whose indicated
subtype is inconsistent with the access type declaration

Parameter(s): [anonymous | inconsisent | not] [<category>|<entity>]
<category>  : ()  | access    | array | delta  | digits |
              mod | protected | range | record | tagged | task
----
Rule: ARRAY_DECLARATIONS
Controls various parameters related to array types or objects declarations

Parameter(1): first     | last | length | dimensions | index |
              component

For First, Last, Length, Dimensions:
Parameter(2..3): <bound> <value>
                (at least one parameter required)
For first, last, and dimensions, alternatively:
Parameter(2): <value>

For index:
Parameter(2..)  : <entity>|<category>

For component:
Parameter(2)  : <entity>|<category>
Parameter(3..): [not] packed | sized | component_sized (optional)

   <bound>: min | max
<category>: ()      | access    | array | delta  | digits | mod |
            private | protected | range | record | tagged | task
----
Rule: ASPECTS
Control occurrences of aspect specifications

Parameter(s): <Aspect_Mark> | all
             (optional, default = all)
----
Rule: BARRIER_EXPRESSIONS
Control constucts used in protected entry barriers

Parameter(s): <entity>            | allocation          | any_component   |
              any_variable        | arithmetic_operator | array_aggregate |
              comparison_operator | conversion          | dereference     |
              indexing            | function_attribute  | local_function  |
              logical_operator    | record_aggregate    | value_attribute
----
Rule: CASE_STATEMENT
Controls various sizes related to the case statement

Parameter(1)   : others_span | paths | range_span | values
Parameter(2..3): <bound> <value>
                (at least one parameter required)
<bound>:  min | max
----
Rule: CHARACTERS
Controls source lines that contain specified kind of characters

Parameter (s): control | not_iso_646 | trailing_space |
               wide
               (optional, default = all)
----
Rule: COMMENTS
Control the content or placement of comments

Parameter (1) pattern | position | terminating | unnamed_begin
for pattern:
   Parameter(2..): "<comment pattern>"
for position:
   Parameter(2..3): [<bound>] <value>
      <bound>     :  min | max
                 (at least one parameter required)
for terminating:
   Parameter(2..): "<allowed pattern>" | begin | end
for unnamed_begin:
   Parameter(2..): [<condition>] <unit>
      <condition>: always | declaration | program_unit
           <unit>: all  | procedure | function | entry | package |
                   task
----
Rule: DECLARATIONS
Control occurrences of Ada declarations

Parameter(s): {<location>} <decl>
<location>: all | block   | library | local      | nested    |
            own | private | public  | in_generic | task_body
<decl>: any_declaration                 | abstract_function                 |
        abstract_operator               | abstract_procedure                |
        abstract_type                   | access_all_type                   |
        access_constant_type            | access_protected_type             |
        access_subprogram_type          | access_task_type                  |
        access_type                     | aliased_array_component           |
        aliased_constant                | aliased_protected_component       |
        aliased_record_component        | aliased_variable                  |
        anonymous_access_component      | anonymous_access_constant         |
        anonymous_access_discriminant   | anonymous_access_parameter        |
        anonymous_access_variable       | anonymous_subtype_allocator       |
        anonymous_subtype_case          | anonymous_subtype_declaration     |
        anonymous_subtype_for           | anonymous_subtype_indexing        |
        array                           | array_type                        |
        binary_modular_type             | box_defaulted_formal_function     |
        box_defaulted_formal_procedure  | character_literal                 |
        child_unit                      | class_wide_constant               |
        class_wide_variable             | constant                          |
        constrained_array_constant      | constrained_array_type            |
        constrained_array_variable      | controlled_type                   |
        decimal_fixed_type              | defaulted_discriminant            |
        defaulted_generic_parameter     | defaulted_parameter               |
        deferred_constant               | derived_type                      |
        discriminant                    | empty_private_part                |
        empty_visible_part              | enumeration_type                  |
        entry                           | exception                         |
        expression_function             | extension                         |
        fixed_type                      | float_type                        |
        formal_function                 | formal_package                    |
        formal_procedure                | formal_type                       |
        function                        | function_call_renaming            |
        function_instantiation          | generic                           |
        generic_function                | generic_package                   |
        generic_procedure               | handlers                          |
        incomplete_type                 | in_out_generic_parameter          |
        in_out_parameter                | initialized_protected_component   |
        initialized_record_component    | initialized_variable              |
        instantiation                   | integer_type                      |
        interface_type                  | library_unit_renaming             |
        limited_private_type            | modular_type                      |
        multiple_names                  | multiple_protected_entries        |
        name_defaulted_formal_function  | name_defaulted_formal_procedure   |
        named_number                    | non_binary_modular_type           |
        non_identical_operator_renaming | non_identical_renaming            |
        non_joint_ce_ne_handler         | non_limited_private_type          |
        non_ravenscar_task              | not_operator_renaming             |
        null_defaulted_formal_procedure | null_extension                    |
        null_ordinary_record_type       | null_procedure                    |
        null_procedure_body             | null_procedure_declaration        |
        null_tagged_type                | operator                          |
        operator_renaming               | ordinary_fixed_type               |
        ordinary_fixed_type_no_small    | ordinary_fixed_type_with_small    |
        ordinary_record_type            | ordinary_record_variable          |
        out_parameter                   | package                           |
        package_instantiation           | package_statements                |
        predefined_operator             | private_extension                 |
        procedure                       | procedure_instantiation           |
        protected                       | protected_discriminant            |
        protected_entry                 | protected_type                    |
        protected_variable              | record_type                       |
        renaming                        | renaming_as_body                  |
        renaming_as_declaration         | scalar_variable                   |
        self_calling_function           | self_calling_procedure            |
        separate                        | signed_type                       |
        single_array                    | single_protected                  |
        single_task                     | subtype                           |
        tagged_private_type             | tagged_type                       |
        tagged_variable                 | task                              |
        task_discriminant               | task_entry                        |
        task_type                       | task_variable                     |
        type                            | unconstrained_array_constant      |
        unconstrained_array_type        | unconstrained_array_variable      |
        unconstrained_subtype           | uninitialized_protected_component |
        uninitialized_record_component  | uninitialized_variable            |
        unknown_discriminant            | variable                          |
        variant_part
----
Rule: DEFAULT_PARAMETER
Control subprogram calls or generic instantiations that use the default for a
given defaulted parameter, or provide it, positionally or using any notation

Parameter 1: <Subprogram or generic name> | calls | instantiations
Parameter 2: <Formal parameter name> | all
Parameter 3: used | positional | not_used
----
Rule: DEPENDENCIES
Control units that depend on a set of allowed/forbidden units,
or whose number of dependencies is not in the specified range

Parameter(1)   : others | with | raw | direct | parent
For subrules "others" and "with":
Parameter(2..3): allowed (resp. forbidden) units
For other subrules:
Parameter(2..3): <bound> <value>
                (at least one parameter required)
<bound>:  min | max
----
Rule: DIRECTLY_ACCESSED_GLOBALS
Control global package variables accessed by other than dedicated subprograms

Parameter(s): plain | accept | protected
              (optional)
----
Rule: DUPLICATE_INITIALIZATION_CALLS
Control that indicated procedures are not called twice with identical in parameters,
or twice on the same out actual parameter

Parameter(s): <Procedure name>
----
Rule: ENTITIES
Control occurrences of any Ada entity

Parameter(s): {<location>} <Entity name>
<location>: block   | library | local      | nested    | own |
            private | public  | in_generic | task_body
----
Rule: ENTITY_INSIDE_EXCEPTION
Control occurrences of an entity inside an exception handler.

Parameter(s): [not] calls | entry_calls | <Entity name>
----
Rule: EXCEPTION_PROPAGATION
Control that certain kinds of subprograms, tasks, or declarations cannot propagate exceptions
and that local exceptions cannot propagate out of scope

Parameter 1     : [<level>,] interface       | parameter   |
                             task            | declaration |
                             local_exception
                             (<level> is required for declaration)
Parameter 2 .. N: for interface: <convention name>
                  for parameter: <full name of parameters known to expect call-backs>
                  for task: nothing
                  for declaration: nothing
                  for local_exception: nothing, no <level> allowed
----
Rule: EXPRESSIONS
Control occurrences of Ada expressions

Parameter (s): and                              | and_array                 |
               and_binary                       | and_boolean               |
               and_then                         | array_aggregate           |
               array_partial_others             | array_non_static_range    |
               array_others                     | array_range               |
               case                             | complex_parameter         |
               downward_conversion              | explicit_dereference      |
               fixed_multiplying_op             | for_all                   |
               for_some                         | if                        |
               if_elsif                         | if_no_else                |
               implicit_dereference             | in                        |
               inconsistent_attribute_dimension | inherited_function_call   |
               mixed_operators                  | not_in                    |
               or                               | or_array                  |
               or_binary                        | or_boolean                |
               or_else                          | parameter_view_conversion |
               prefixed_operator                | real_equality             |
               record_aggregate                 | record_partial_others     |
               record_others                    | static_membership         |
               slice                            | type_conversion           |
               underived_conversion             | universal_range           |
               unqualified_aggregate            | upward_conversion         |
               xor                              | xor_array                 |
               xor_binary                       | xor_boolean
For all *_conversion subrules:
    [[<source_category>] <target_category>] <subrule>
For subrules inherited_function_call and prefixed_operator:
    [<result_category>] <subrule>
Categories: <>     | ()      | range  | mod       | delta  |
            digits | array   | record | tagged    | access |
            new    | private | task   | protected
----
Rule: GENERIC_ALIASING
Control instantiations where the same actual is given for
more than one formal
Parameter(s): [<condition>]  all        | variable | type |
                             subprogram | package
                             (optional, default = all)
 <condition>:  unlikely | possible | certain
               (default = certain)
----
Rule: GLOBAL_REFERENCES
Control global (in a relative sense) variables referenced 
directly or indirectly from some specific constructs

Parameter(1):  all                 | read     |
               written             | multiple |
               multiple_non_atomic
Parameter(2..N):  <name> | task | protected | function | procedure
----
Rule: HEADER_COMMENTS
Control that  each unit starts with at least indicated number of comment lines
or matches the specified model

Parameter (1): minimum | model
For minimum:
   Parameter (2) : <Required number of comment lines>
For model:
   Parameter (2) : <model file>
----
Rule: IMPROPER_INITIALIZATION
Control out parameters and local variables that are improperly initialized
(not initialized for all paths, or given an unnecessary initial value)

Parameter(s): {<extras>} out_parameter        | variable |
                         initialized_variable
    <extras>: access | limited | package | return
----
Rule: INSTANTIATIONS
Control generic instantiations of specified units, either all of them
or those made with the indicated actual parameters.
Optionally, control is restricted to instantiations appearing at indicated locations

Parameter 1     : {<location>} <Generic name>
Parameter 2 .. N: <Entity name> | <category> | <> | = (optional)
<location>      : all        | block     | library | local  |
                  nested     | own       | private | public |
                  in_generic | task_body
<category>      : ()      | access   | array | delta  | digits | mod |
                  private |protected | range | record | tagged | task
----
Rule: INSUFFICIENT_PARAMETERS
Control calls where absence of named notation can lead to confusion

Parameter(1): Allowed number of "insufficient" parameters
Parameter(2..N): Enumeration type names whose values are insufficient
----
Rule: LOCAL_ACCESS
Control usage of non-local 'Access attribute (and similar ones)

Parameter(s):  constant            | function           |
               procedure           | protected_function |
               protected_procedure | variable
----
Rule: LOCAL_HIDING
Control occurrences of local identifiers that hide or overload an identical name

Parameter(1): <exceptions>  strict | overloading
                            (default = strict)
Parameter(2..N): "<Allowed Pattern>"
<exceptions>: not_operator           | not_enumeration |
              not_identical_renaming
Variables:
Local_Hiding.Overloading_Report: (Compact, Detailed) = Detailed
----
Rule: MAX_BLANK_LINES
Control that there is no more than the indicated number of consecutive blank lines

Parameter: <Max allowed consecutive blank lines>
----
Rule: MAX_CALL_DEPTH
Control maximum call depth

Parameter: <Allowed depth> | finite
----
Rule: MAX_LINE_LENGTH
Control that no source line is longer than the indicated maximum

Parameter: <Max allowed length>
----
Rule: MAX_NESTING
Control scopes nested deeper than a given limit.

Paramater (1):  all | generic | separate | task
                (optional, default=all)
Parameter (2): <maximum allowed nesting level>
----
Rule: MAX_SIZE
Control the maximum length of Ada statements

Parameter(1): accept         | block         | case           |
              case_branch    | if            | if_branch      |
              loop           | simple_block  | unnamed_block  |
              unnamed_loop   | package_spec  | package_body   |
              procedure_body | function_body | protected_spec |
              protected_body | entry_body    | task_spec      |
              task_body      | unit
Parameter(2): maximum acceptable number of lines
----
Rule: MAX_STATEMENT_NESTING
Control max nesting of compound statements

Parameter 1: block | case | if | loop | all
Parameter 2: nesting depth
----
Rule: MOVABLE_ACCEPT_STATEMENTS
Control (re)movable statements from `accept' bodies.
Movable statements might be moved to an outer scope.

Parameter(1): certain | possible
Parameter(2..N): <name>
----
Rule: MULTIPLE_ASSIGNMENTS
Control repeated assignments in a sequence to a same variable, or sequences of assignments
to components of a structured variable that could be replaced by an aggregate

Parameter (1) : repeated | groupable
For groupable:
Parameter(2..n): <criterion> <value>
<criterion> : given | missing | ratio
----
Rule: NAMING_CONVENTION
Control the form of allowed (or forbidden) names in declarations

Parameter 1: [root] [others] [global|local|unit]
                 all                        | type                       |
                 discrete_type              | enumeration_type           |
                 integer_type               | signed_integer_type        |
                 modular_integer_type       | floating_point_type        |
                 fixed_point_type           | binary_fixed_point_type    |
                 decimal_fixed_point_type   | array_type                 |
                 record_type                | regular_record_type        |
                 tagged_type                | interface_type             |
                 class_type                 | access_type                |
                 access_to_regular_type     | access_to_tagged_type      |
                 access_to_class_type       | access_to_sp_type          |
                 access_to_task_type        | access_to_protected_type   |
                 private_type               | private_extension          |
                 generic_formal_type        | variable                   |
                 regular_variable           | field                      |
                 discriminant               | record_field               |
                 protected_field            | procedure_formal_out       |
                 procedure_formal_in_out    | generic_formal_in_out      |
                 constant                   | regular_constant           |
                 regular_static_constant    | regular_nonstatic_constant |
                 named_number               | integer_number             |
                 real_number                | enumeration                |
                 sp_formal_in               | generic_formal_in          |
                 loop_control               | occurrence_name            |
                 entry_index                | label                      |
                 stmt_name                  | loop_name                  |
                 block_name                 | subprogram                 |
                 procedure                  | regular_procedure          |
                 protected_procedure        | generic_formal_procedure   |
                 function                   | regular_function           |
                 protected_function         | generic_formal_function    |
                 entry                      | task_entry                 |
                 protected_entry            | package                    |
                 regular_package            | generic_formal_package     |
                 task                       | task_type                  |
                 task_object                | protected                  |
                 protected_type             | protected_object           |
                 exception                  | generic                    |
                 generic_package            | generic_sp                 |
                 generic_procedure          | generic_function           |
                 renaming                   | object_renaming            |
                 exception_renaming         | package_renaming           |
                 subprogram_renaming        | procedure_renaming         |
                 function_renaming          | generic_renaming           |
                 generic_package_renaming   | generic_sp_renaming        |
                 generic_procedure_renaming | generic_function_renaming
Parameter 2..N: [case_sensitive|case_insensitive] [not] "<name pattern>"
Variables:
Naming_Convention.Default_Case_Sensitivity: (Off, On) = Off
----
Rule: NON_STATIC
Control that indicated contexts use only static expressions

Parameter(s): variable_initialization | constant_initialization |
              index_constraint        | discriminant_constraint |
              instantiation           | index_check
              (optional, default = all)
----
Rule: NOT_ELABORATION_CALLS
Control subprogram calls or allocators that happen elsewhere than
as part of the elaboration of a library package.

Parameter(s): <subprogram name>|new
----
Rule: NOT_SELECTED_NAME
Control usages of an Ada entities that do not use selected notation

Parameter(1) : none | unit | compilation | family
Parameter(2..): <Entity name>
----
Rule: NO_OPERATOR_USAGE
Control integer types where no operators, except as indicated, are used

Parameter: none | logical
----
Rule: OBJECT_DECLARATIONS
Control allowed forms of object declarations

Parameter(1): type                | min_integer_span     |
              volatile_no_address | address_not_volatile
Parameter(2..)
   for Type            : [constant|variable] <entity>
   for Min_Integer_Span: [constant|variable] <value>
----
Rule: PARAMETER_ALIASING
Control subprogram or entry calls where the same variable is given
for more than one [in] out parameter.
If "with_in" is given, consider also in parameters

Parameter 1: [with_in]  unlikely | possible | certain
                        (optional, default=certain)
----
Rule: PARAMETER_DECLARATIONS
Controls form and metrics of parameters of callable entities

Parameter (1): all_parameters       | in_parameters         |
               defaulted_parameters | out_parameters        |
               in_out_parameters    | access_parameters     |
               tagged_parameters    | class_wide_parameters |
               single_out_parameter
For all subrules except Single_Out_Parameter:
Parameter(2..3): <bound> <value>
                (at least one parameter required)
   <bound>: min | max
For Single_Out_Parameter:
  No value allowed
Other parameters: function             | procedure             |
                  dispatching_function | dispatching_procedure |
                  protected_function   | protected_procedure   |
                  protected_entry      | task_entry
                  (optional, default = all)
----
Rule: POSITIONAL_ASSOCIATIONS
Control use of positional_association:
   Parameter (1): all | all_positional | same_type
   Parameter (2): <value>
   Parameter (3): [not_operator] pragma          | call             |
                                 instantiation   | discriminant     |
                                 array_aggregate | record_aggregate
                                 (default = all)
   Parameter (4..): <entities>
                    (entities not required to follow the rule)
----
Rule: POTENTIALLY_BLOCKING_OPERATIONS
Control calls to potentially blocking operations from protected operations

Parameter(s): None
----
Rule: PRAGMAS
Control usage of specific pragmas

Parameter(s): [multiple] all | nonstandard | <pragma names>
----
Rule: RECORD_DECLARATIONS
Controls various parameters related to record types declarations

Parameter(1): component
For component:
Parameter(2)  : <entity>|<category>
  <category>  : ()      | access    | array | delta  | digits | mod |
                private | protected | range | record | tagged | task
Parameter(3..): [not] in_variant | packed | sized | initialized | aligned (optional)
----
Rule: REDUCEABLE_SCOPE
Control declarations that could be moved to an inner scope,
I.e. where all references are from a single nested scope

Parameter(s): {<restriction>} all        | variable | constant |
                              subprogram | type     | package  |
                              exception  | generic  | use
                              (optional)
<restriction>: no_blocks | to_body
----
Rule: REPRESENTATION_CLAUSES
Control occurrences of representation clauses

Parameter(s): [<categories>] [global] [object] <specifiable attribute> |
                             at                                        |
                             at_mod                                    |
                             enumeration                               |
                             fractional_size                           |
                             incomplete_layout                         |
                             layout                                    |
                             non_aligned_component                     |
                             non_contiguous_layout                     |
                             overlay
                             (optional)
Categories: <>     | ()    | range   | mod    | delta     |
            digits | array | record  | tagged | extension |
            access | new   | private | task   | protected
----
Rule: RETURN_TYPE
Control various forms of the type returned by functions

Parameter(s):  class_wide                  | limited_class_wide  |
               protected                   | task                |
               constrained_array           | unconstrained_array |
               unconstrained_discriminated | anonymous_access
----
Rule: SIDE_EFFECT_PARAMETERS
Control subprogram calls or generic instantiations that call
functions with side effect and where the order of evaluation matters

Parameter(s): <side effect function names>
----
Rule: SILENT_EXCEPTIONS
Control exception handlers that do not re-raise an exception 
nor call a report procedure

Parameter(s)   : <control-item> | <report-item>
<control-item> : not | with   <exception> | <library unit> | others
 <report-item> : raise | explicit_raise | reraise |
                 return | requeue | <report procedure name>
----
Rule: SIMPLIFIABLE_EXPRESSIONS
Control occurrence of various forms of expressions that could be made simpler:
  T'FIRST .. T'LAST that can be replaced by T'RANGE or T.
  <expression> = (/=) True/False
  not <comparison>
  Unnecessary parentheses
  Conversions of universal values, or to the expression's subtype

Parameter(s): conversion  | parentheses  | range   | logical_false |
              logical_not | logical_true | logical
              (optional, default=all)
----
Rule: SIMPLIFIABLE_STATEMENTS
Control Ada statements that can be made simpler

Parameter(s): block | dead           | handler     |
              if    | if_for_case    | if_not      |
              loop  | loop_for_while | nested_path |
              null
----
Rule: STATEMENTS
Control occurrences of Ada statements

Parameter(s): any_statement           | abort                    |
              accept                  | accept_return            |
              assignment              | asynchronous_select      |
              block                   | case                     |
              case_others             | case_others_null         |
              code                    | conditional_entry_call   |
              declare_block           | delay                    |
              delay_until             | dispatching_call         |
              effective_declare_block | entry_call               |
              entry_return            | exception_others         |
              exception_others_null   | exit                     |
              exit_expanded_name      | exit_for_loop            |
              exit_outer_loop         | exit_plain_loop          |
              exit_while_loop         | exited_extended_return   |
              extended_return         | for_loop                 |
              for_in_loop             | for_iterator_loop        |
              for_of_loop             | function_return          |
              goto                    | if                       |
              if_elsif                | inherited_procedure_call |
              labelled                | loop_return              |
              multiple_exits          | named_exit               |
              no_else                 | null                     |
              procedure_return        | raise                    |
              raise_locally_handled   | raise_nonpublic          |
              raise_standard          | reraise                  |
              requeue                 | selective_accept         |
              simple_block            | simple_loop              |
              terminate               | timed_entry_call         |
              unconditional_exit      | unnamed_block            |
              unnamed_exit            | unnamed_loop_exited      |
              unnamed_for_loop        | unnamed_multiple_loop    |
              unnamed_simple_block    | unnamed_simple_loop      |
              unnamed_while_loop      | untyped_for              |
              while_loop
----
Rule: STYLE
Control various Ada style issues

Parameter(1): casing_attribute       | casing_identifier |
              casing_keyword         | casing_pragma     |
              compound_statement     | default_in        |
              exposed_literal        | multiple_elements |
              negative_condition     | no_closing_name   |
              numeric_literal        | parameter_order   |
              formal_parameter_order | renamed_entity
For casing_*:
   Parameter (2): uppercase | lowercase | titlecase | original
                  (default = Original)
For exposed_literal:
   Parameter (2)  : integer | real | character | string
   Parameter (3..): [max] <value> | declaration | constant | number      |
                    var_init      | type        | pragma   | repr_clause |
                    index         | exponent
                    (optional)
For multiple_elements:
   Parameter (2..): [flexible] clause | declaration | statement
                               (default = all)
For no_closing_name:
   Parameter (2): maximum number of lines allowed
For numeric_literal:
   Parameter (2): [not] <base>
   Parameter (3): <block_size>
For parameter_order:
   parameter (2..): list of in        | defaulted_in | access  |
                            in_out    | out          | type    |
                            procedure | function     | package
----
Rule: TERMINATING_TASKS
Control task termination.

Parameter(s): none
----
Rule: TYPE_INITIAL_VALUES
Control types without proper initialization constants

Parameter(1): <pattern>
----
Rule: UNCHECKABLE
Control occurrences of uncheckable constructs in other rules

Parameter(s): false_positive | false_negative | missing_unit
              (optional, default = all)
----
Rule: UNITS
Control units not analyzed, or not referenced from the rest of the project

Parameter(s): unreferenced | unchecked
----
Rule: UNIT_PATTERN
Controls various usage patterns of units and entities in them

Parameters: single_tagged_type | tagged_type_hierarchy
----
Rule: UNNECESSARY_USE_CLAUSE
Control use clauses that can be removed, moved, or changed to use type.

Parameter(s): unused | qualified | operator | nested | movable
----
Rule: UNSAFE_ELABORATION
Controls elaboration code of (generic) packages that may cause elaboration issues

Parameter(s): none
----
Rule: UNSAFE_PAIRED_CALLS
Controls calls like P/V operations that are not safely paired

Parameter(1): First subprogram
Parameter(2): Second subprogram
Parameter(3): (optional) type of lock parameter
----
Rule: UNSAFE_UNCHECKED_CONVERSION
Control unsafe usage of Unchecked_Conversion

Parameter(s): none
----
Rule: USAGE
Control usage of various entities
(possibly restricted to those that match the specified location and properties)

Parameter(s): variable | object    {, [not] <location> | initialized | read | written}
  or        : constant             {, [not] <location> | read}
  or        : type                 {, [not] <location> | used}
  or        : procedure | function {, [not] <location> | called}
  or        : exception            {, [not] <location> | raised | handled}
  or        : task                 {, [not] <location> | called | aborted}
  or        : protected            {, [not] <location> | called}
  or        : generic              {, [not] <location> | instantiated}
  or        : all                  [, [not] <location>]
location ::= from_visible | from_private | from_spec
----
Rule: USE_CLAUSES
Control occurrences of use clauses that mention
any package but the ones passed as parameters (if any)

Parameter(1):  <Allowed package name> | local | global
               (optional)
Parameter(2..): <Allowed package name>
----
Rule: WITH_CLAUSES
Control "with" clauses that use multiple names, can be moved to a more reduced scope,
or are implicitely inherited from a parent unit

Parameter(s): multiple_names | reduceable | inherited
Variables:
With_Clauses.Check_Private_With: (Off, On) = On
Usage: adactl [-deEirsTuvwx]
              [-p <project file>]     [-f <rules file>]    [-l < rules list > ]
              [-o < output file > ]   [-t <trace file>]    [-F <format>]
              [-S <statistics level>] [-m <warning limit>] [-M <message limit>]
              <unit>[+|-<unit>]|[@]<file> ... [-- <ASIS options>]
       adactl -h [<help item>...]
       adactl -I [-deEirsTuvwx]
              [-p <project file>]     [-f <rules file>]    [-l < rules list > ]
              [-o < output file > ]   [-t <trace file>]    [-F <format>]
              [-S <statistics level>] [-m <warning limit>] [-M <message limit>]
              <unit>[+|-<unit>]|[@]<file> ... [-- <ASIS options>]
       adactl -D [-rswx] [-p <project file>] [-o <output file>] 
              <unit>[+|-<unit>]|[@]<file> ... [-- <ASIS options>]
       adactl -C [-dvx] [-f <rules file>] [-l <rules list>]

Special modes:
   -h           prints general help message (options, rules, version, license)
   -h <rule>... prints specific rule(s) help (<rule> can be a regexp)
   -h all       prints all rules help
   -h commands  prints commands help
   -h license   prints license information
   -h list      prints all rules names (GPS format)
   -h options   prints command-line options help
   -h rules     prints all rules names (normal format)
   -h variables prints values of all global and rules variables
   -h version   prints version information
   -I           interactive mode
   -D           generate dependencies
   -C           check rules syntax only
Options:
   -d        enable debug mode
   -e        treat warnings (Search) as errors (Check)
   -E        print only errors (Check)
   -f file   use a file for the specification of rules
   -F format choose output format (GNAT, GNAT_SHORT, CSV, CSV_SHORT, CSVX, CSVX_SHORT, NONE)
   -i        ignore local deactivations
   -j        invert local deactivations
   -l rules  process with these rules
   -o file   specify an output file
   -p file   specify an emacs ada-mode project file (.adp)
   -r        recursive
   -s        process specifications only
   -S        statistics level (0 .. 3)
   -t file   specify a trace file
   -T        Report execution time of rules
   -u        treat all parameters as Ada units
   -v        enable verbose mode
   -w        overwrite output file (works with -o)
   -x        exit when internal error
----
Rules:
   Abnormal_Function_Return        Allocators                      
   Array_Declarations              Aspects                         
   Barrier_Expressions             Case_Statement                  
   Characters                      Comments                        
   Declarations                    Default_Parameter               
   Dependencies                    Directly_Accessed_Globals       
   Duplicate_Initialization_Calls  Entities                        
   Entity_Inside_Exception         Exception_Propagation           
   Expressions                     Generic_Aliasing                
   Global_References               Header_Comments                 
   Improper_Initialization         Instantiations                  
   Insufficient_Parameters         Local_Access                    
   Local_Hiding                    Max_Blank_Lines                 
   Max_Call_Depth                  Max_Line_Length                 
   Max_Nesting                     Max_Size                        
   Max_Statement_Nesting           Movable_Accept_Statements       
   Multiple_Assignments            Naming_Convention               
   Non_Static                      Not_Elaboration_Calls           
   Not_Selected_Name               No_Operator_Usage               
   Object_Declarations             Parameter_Aliasing              
   Parameter_Declarations          Positional_Associations         
   Potentially_Blocking_Operations Pragmas                         
   Record_Declarations             Reduceable_Scope                
   Representation_Clauses          Return_Type                     
   Side_Effect_Parameters          Silent_Exceptions               
   Simplifiable_Expressions        Simplifiable_Statements         
   Statements                      Style                           
   Terminating_Tasks               Type_Initial_Values             
   Uncheckable                     Units                           
   Unit_Pattern                    Unnecessary_Use_Clause          
   Unsafe_Elaboration              Unsafe_Paired_Calls             
   Unsafe_Unchecked_Conversion     Usage                           
   Use_Clauses                     With_Clauses                    

ADACTL v. 1.16b4 with ASIS 2.0.R for GNAT GPL 2013 (20130314)
----
Copyright (C) 2004-2013 Eurocontrol/Adalog and others.
This software is covered by the GNU Modified General Public License.
Rule: SIMPLIFIABLE_EXPRESSIONS
Control occurrence of various forms of expressions that could be made simpler:
  T'FIRST .. T'LAST that can be replaced by T'RANGE or T.
  <expression> = (/=) True/False
  not <comparison>
  Unnecessary parentheses
  Conversions of universal values, or to the expression's subtype

Parameter(s): conversion  | parentheses  | range   | logical_false |
              logical_not | logical_true | logical
              (optional, default=all)
----
Rule: SIMPLIFIABLE_STATEMENTS
Control Ada statements that can be made simpler

Parameter(s): block | dead           | handler     |
              if    | if_for_case    | if_not      |
              loop  | loop_for_while | nested_path |
              null
Variables: 
Tag1: String = "##"
Tag2: String = "##"
