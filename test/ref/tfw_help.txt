Rule: ABNORMAL_FUNCTION_RETURN
Parameter(s): none
Control functions that can propagate Program_Error due to not executing a return statement

Rule: ALLOCATORS
Parameter(s): task | protected | <allocated type> (optional)
Control occurrences of allocators, either all of them,
or just those for tasks, protected types, or specific type(s)

Rule: ARRAY_DECLARATIONS
Parameter(1): first | max_length
Parameter(2): for first      : required value of the lower bound
              for max_length : maximum allowed length of the array
Controls various sizes related to array types or objects declarations

Rule: BARRIER_EXPRESSIONS
Parameter(s): <entity>            | allocation          | any_component   |
              any_variable        | arithmetic_operator | array_aggregate |
              comparison_operator | conversion          | dereference     |
              indexing            | function_attribute  | local_function  |
              logical_operator    | record_aggregate    | value_attribute
Control constucts used in protected entry barriers

Rule: CASE_STATEMENT
Parameter(1)   : others_span | paths | range_span | values
Parameter(2..3): <bound> <value>
                (at least one parameter required)
<bound>:  min | max
Controls various sizes related to the case statement

Rule: CHARACTERS
Parameter (s): control | not_iso_646 | trailing_space |
               wide
               (optional, default = all)
Controls source lines that contain specified kind of characters

Rule: DECLARATIONS
Parameter(s): {<location>} <decl_kind>
<location>: all | block   | library | local     | nested |
            own | private | public  | task_body
<decl_kind>: any_declaration                 | abstract_function              |
             abstract_procedure              | abstract_type                  |
             access_all_type                 | access_constant_type           |
             access_protected_type           | access_subprogram_type         |
             access_task_type                | access_type                    |
             aliased                         | anonymous_subtype_allocator    |
             anonymous_subtype_case          | anonymous_subtype_declaration  |
             anonymous_subtype_for           | anonymous_subtype_indexing     |
             array                           | array_type                     |
             binary_modular_type             | character_literal              |
             child_unit                      | class_wide_constant            |
             class_wide_variable             | constant                       |
             constrained_array_type          | constrained_array_variable     |
             controlled_type                 | decimal_fixed_type             |
             defaulted_discriminant          | defaulted_generic_parameter    |
             defaulted_parameter             | deferred_constant              |
             derived_type                    | discriminant                   |
             empty_private_part              | empty_visible_part             |
             enumeration_type                | entry                          |
             exception                       | extension                      |
             fixed_type                      | float_type                     |
             formal_function                 | formal_package                 |
             formal_procedure                | formal_type                    |
             function                        | function_call_renaming         |
             function_instantiation          | generic                        |
             generic_function                | generic_package                |
             generic_procedure               | handlers                       |
             incomplete_type                 | in_out_generic_parameter       |
             in_out_parameter                | initialized_record_field       |
             initialized_protected_field     | instantiation                  |
             integer_type                    | limited_private_type           |
             modular_type                    | multiple_names                 |
             multiple_protected_entries      | named_number                   |
             non_binary_modular_type         | non_identical_renaming         |
             non_identical_operator_renaming | non_limited_private_type       |
             not_operator_renaming           | null_extension                 |
             null_ordinary_record_type       | null_procedure                 |
             null_tagged_type                | operator                       |
             operator_renaming               | ordinary_fixed_type            |
             ordinary_fixed_type_no_small    | ordinary_fixed_type_with_small |
             ordinary_record_type            | out_parameter                  |
             package                         | package_instantiation          |
             package_statements              | predefined_operator            |
             private_extension               | procedure                      |
             procedure_instantiation         | protected                      |
             protected_entry                 | protected_type                 |
             record_type                     | renaming                       |
             separate                        | signed_type                    |
             single_array                    | single_protected               |
             single_task                     | subtype                        |
             tagged_type                     | task                           |
             task_entry                      | task_type                      |
             type                            | unconstrained_array_type       |
             unconstrained_array_variable    | unconstrained_subtype          |
             uninitialized_protected_field   | uninitialized_record_field     |
             uninitialized_variable          | variable                       |
             variant_part
Control occurrences of Ada declarations

Rule: DEFAULT_PARAMETER
Parameter 1: <Subprogram or generic name> | calls | instantiations |
             all
Parameter 2: <Formal parameter name> | all
Parameter 3: used | positional | not_used
Control subprogram calls or generic instantiations that use the default for a
given defaulted parameter, or provide it, positionally or using any notation

Rule: DEPENDENCIES
Parameter(1)   : others | raw | direct | parent
For subrule "others":
Parameter(2..3): allowed units
For other subrules:
Parameter(2..3): <bound> <value>
                (at least one parameter required)
<bound>:  min | max
Control units that depend on units others than those indicated,
or whose number of dependencies is not in the specified range

Rule: DIRECTLY_ACCESSED_GLOBALS
Parameter(s): plain | accept | protected
              (optional)
Control global package variables accessed by other than dedicated subprograms

Rule: DUPLICATE_INITIALIZATION_CALLS
Parameter(s): <Procedure name>
Control that indicated procedures are not called twice with identical in parameters,
or twice on the same out actual parameter

Rule: ENTITIES
Parameter(s): <Entity name>
Control occurrences of any Ada entity

Rule: ENTITY_INSIDE_EXCEPTION
Parameter(s): [not] calls | <Entity name>
Control occurrences of an entity inside an exception handler.

Rule: EXCEPTION_PROPAGATION
Parameter 1     : [<level>,] interface       | parameter   |
                             task            | declaration |
                             local_exception
                             (<level> is required for declaration)
Parameter 2 .. N: for interface: <convention name>
                  for parameter: <full name of parameters known to expect call-backs>
                  for task: nothing
                  for declaration: nothing
                  for local_exception: nothing, no <level> allowed
Control that certain kinds of subprograms, tasks, or declarations cannot propagate exceptions
and that local exceptions cannot propagate out of scope

Rule: EXPRESSIONS
Parameter (s): and                              | and_then              |
               array_aggregate                  | array_partial_others  |
               array_others                     | complex_parameter     |
               inconsistent_attribute_dimension | mixed_operators       |
               or                               | or_else               |
               real_equality                    | record_aggregate      |
               record_partial_others            | record_others         |
               slice                            | type_conversion       |
               universal_range                  | unqualified_aggregate |
               xor
Control occurrences of Ada expressions

Rule: GLOBAL_REFERENCES
Parameter(1):  all                 | multiple |
               multiple_non_atomic
Parameter(2..N):  <name> | task | protected | function | procedure
Control global (in a relative sense) variables referenced 
directly or indirectly from some specific constructs

Rule: HEADER_COMMENTS
Parameter (1): minimum | model
For minimum:
   Parameter (2) : <Required number of comment lines>
For model:
   Parameter (2) : <model file>
Control that  each unit starts with at least indicated number of comment lines
or matches the specified model

Rule: IMPROPER_INITIALIZATION
Parameter(s): [access] [limited] out_parameter        | variable |
                                 initialized_variable
Control out parameters and local variables that are improperly initialized
(not initialized for all paths, or given an unnecessary initial value)

Rule: INSTANTIATIONS
Parameter 1     : {<location>} <Generic name>
Parameter 2 .. N: <Entity name> | <> | = (optional)
<location>      : all | block   | library | local     | nested |
                  own | private | public  | task_body
Control generic instantiations of specified units, either all of them
or those made with the indicated actual parameters.
Optionally, control is restricted to instantiations appearing at indicated locations

Rule: INSUFFICIENT_PARAMETERS
Parameter(1): Allowed number of "insufficient" parameters
Parameter(2..N): Enumeration type names whose values are insufficient
Control calls where absence of named notation can lead to confusion

Rule: LOCAL_HIDING
Parameter(s):  strict | overloading | both
               (default = strict)
Control occurrences of local identifiers that hide an outer identical name

Rule: MAX_BLANK_LINES
Parameter: <Max allowed consecutive blank lines>
Control that there is no more than the indicated number of consecutive blank lines

Rule: MAX_CALL_DEPTH
Parameter: <Allowed depth> | finite
Control maximum call depth

Rule: MAX_LINE_LENGTH
Parameter: <Max allowed length>
Control that no source line is longer than the indicated maximum

Rule: MAX_NESTING
Parameter 1: <maximum allowed nesting level>
Control scopes nested deeper than a given limit.

Rule: MAX_SIZE
Parameter(1): accept        | block        | case | case_branch  |
              if            | if_branch    | loop | simple_block |
              unnamed_block | unnamed_loop
Parameter(2): maximum acceptable number of lines
Control the maximum length of Ada statements

Rule: MAX_STATEMENT_NESTING
Parameter 1: block | case | if | loop | all
Parameter 2: nesting depth
Control max nesting of compound statements

Rule: MOVABLE_ACCEPT_STATEMENTS
Parameter(1): both | certain | possible
Parameter(2..N): <name>
Control (re)movable statements from `accept' bodies.
Movable statements might be moved to an outer scope.

Rule: MULTIPLE_ASSIGNMENTS
Parameter (1) : repeated | groupable
For groupable:
Parameter(2..n): <criterion> <value>
<criterion> : given | missing | ratio
Control repeated assignments in a sequence to a same variable, or sequences of assignments
to components of a structured variable that could be replaced by an aggregate

Rule: NAMING_CONVENTION
Parameter 1: [root] [others] [global|local|unit]
                 all                       | type                       |
                 discrete_type             | enumeration_type           |
                 integer_type              | signed_integer_type        |
                 modular_integer_type      | floating_point_type        |
                 fixed_point_type          | binary_fixed_point_type    |
                 decimal_fixed_point_type  | array_type                 |
                 record_type               | regular_record_type        |
                 tagged_type               | class_type                 |
                 access_type               | access_to_regular_type     |
                 access_to_tagged_type     | access_to_class_type       |
                 access_to_sp_type         | access_to_task_type        |
                 access_to_protected_type  | private_type               |
                 private_extension         | generic_formal_type        |
                 variable                  | regular_variable           |
                 field                     | discriminant               |
                 record_field              | protected_field            |
                 procedure_formal_out      | procedure_formal_in_out    |
                 generic_formal_in_out     | constant                   |
                 regular_constant          | named_number               |
                 integer_number            | real_number                |
                 enumeration               | sp_formal_in               |
                 generic_formal_in         | loop_control               |
                 occurrence_name           | entry_index                |
                 label                     | stmt_name                  |
                 loop_name                 | block_name                 |
                 subprogram                | procedure                  |
                 regular_procedure         | protected_procedure        |
                 generic_formal_procedure  | function                   |
                 regular_function          | protected_function         |
                 generic_formal_function   | entry                      |
                 task_entry                | protected_entry            |
                 package                   | regular_package            |
                 generic_formal_package    | task                       |
                 task_type                 | task_object                |
                 protected                 | protected_type             |
                 protected_object          | exception                  |
                 generic                   | generic_package            |
                 generic_sp                | generic_procedure          |
                 generic_function          | renaming                   |
                 object_renaming           | exception_renaming         |
                 package_renaming          | subprogram_renaming        |
                 procedure_renaming        | function_renaming          |
                 generic_renaming          | generic_package_renaming   |
                 generic_sp_renaming       | generic_procedure_renaming |
                 generic_function_renaming
Parameter 2..N: [case_sensitive|case_insensitive] [not] "<name pattern>"
Control the form of allowed (or forbidden) names in declarations

Rule: NON_STATIC
Parameter(s): variable_initialization | constant_initialization |
              index_constraint        | discriminant_constraint |
              instantiation           | index_check
              (optional, default = all)
Control that index and discriminant constraints use only static expressions

Rule: NOT_ELABORATION_CALLS
Parameter(s): <subprogram name>|new
Control subprogram calls or allocators that happen elsewhere than
as part of the elaboration of a library package.

Rule: NOT_SELECTED_NAME
Parameter(1) : none | unit | compilation | family
Parameter(2..): <Entity name>
Control usages of an Ada entities that do not use selected notation

Rule: NO_OPERATOR_USAGE
Parameter: none | logical
Control integer types where no operators, except as indicated, are used

Rule: OBJECT_DECLARATIONS
Parameter(1): min_integer_span | volatile_no_address
Parameter(2..)
   for Min_Integer_Span: [all|constant|variable] <value>
Control allowed forms of object declarations

Rule: PARAMETER_ALIASING
Parameter 1: [with_in]  unlikely | possible | certain
                        (optional, default=certain)
Control subprogram or entry calls where the same variable is given
for more than one [in] out parameter.
If "with_in" is given, consider also in parameters

Rule: PARAMETER_DECLARATIONS
Parameter (1): max_parameters           | min_parameters       |
               max_defaulted_parameters | single_out_parameter
For Min_Parameters:
  Parameter (2) : minimum required number of parameters
For Max_Parameters:
  Parameter (2) : maximum allowed number of parameters
For Max_Defaulted_Parameters:
  Parameter (2) : maximum allowed number of parameters with default values
For Single_Out_Parameter:
  No value allowed
Other parameters: function            | procedure          |
                  protected_entry     | protected_function |
                  protected_procedure | task_entry
                  (optional, default = all)
Controls form and metrics of parameters of callable entities

Rule: POTENTIALLY_BLOCKING_OPERATIONS
Parameter(s): None
Control calls to potentially blocking operations from protected operations

Rule: PRAGMAS
Parameter(s): all | nonstandard | <pragma names>
Control usage of specific pragmas

Rule: REDUCEABLE_SCOPE
Parameter(s): [no_blocks] all  | variable | constant  | subprogram |
                          type | package  | exception | generic    |
                          use
                          (optional)
Control declarations that could be moved to an inner scope,
I.e. where all references are from a single nested scope

Rule: REPRESENTATION_CLAUSES
Parameter(s): <specifiable attribute> | at                    |
              at_mod                  | enumeration           |
              record                  | fractional_size       |
              incomplete_record       | non_contiguous_record |
              overlay
              (optional)
Control occurrences of representation clauses

Rule: RETURN_TYPE
Parameter(s):  class_wide          | unconstrained_discriminated |
               unconstrained_array | protected                   |
               task
Control various forms of the type returned by functions

Rule: SIDE_EFFECT_PARAMETERS
Parameter(s): <side effect function names>
Control subprogram calls or generic instantiations that call
functions with side effect and where the order of evaluation matters

Rule: SILENT_EXCEPTIONS
Parameter(s)   : <control-item> | <report-item>
<control-item> : not | with   <exception> | <library unit> | others
 <report-item> : raise | explicit_raise | reraise |
                 return | requeue | <report procedure name>
Control exception handlers that do not re-raise an exception 
nor call a report procedure

Rule: SIMPLIFIABLE_EXPRESSIONS
Parameter(s): range       | logical_true | logical_false | logical_not |
              parentheses | conversion   | logical
              (optional, default=all)
Control occurrence of various forms of expressions that could be made simpler:
  T'FIRST .. T'LAST that can be replaced by T'RANGE or T.
  <expression> = (/=) True/False
  not <comparison>
  Unnecessary parentheses
  Conversions to the expression's subtype

Rule: SIMPLIFIABLE_STATEMENTS
Parameter(s): block | dead           | handler     |
              if    | if_for_case    | if_not      |
              loop  | loop_for_while | nested_path |
              null
Control Ada statements that can be made simpler

Rule: SPECIAL_COMMENTS
Parameter (1) pattern | unnamed_begin
for pattern:
   Parameter(2..): "<comment pattern>"
for unnamed_begin:
   Parameter(2..): [<condition>] <unit>
      <condition>: always | declaration | program_unit
           <unit>: all  | procedure | function | entry | package |
                   task
Control comments that match the specified pattern
or "begin" without a comment identifying the program unit

Rule: STATEMENTS
Parameter(s): any_statement          | abort                   |
              accept_return          | assignment              |
              asynchronous_select    | block                   |
              case                   | case_others             |
              case_others_null       | code                    |
              conditional_entry_call | declare_block           |
              delay                  | delay_until             |
              dispatching_call       | effective_declare_block |
              entry_return           | exception_others        |
              exception_others_null  | exit                    |
              exit_expanded_name     | exit_for_loop           |
              exit_outer_loop        | exit_while_loop         |
              for_loop               | function_return         |
              goto                   | if                      |
              if_elsif               | labelled                |
              loop_return            | multiple_exits          |
              no_else                | null                    |
              procedure_return       | raise                   |
              raise_locally_handled  | raise_nonpublic         |
              raise_standard         | reraise                 |
              requeue                | selective_accept        |
              simple_loop            | terminate               |
              timed_entry_call       | unconditional_exit      |
              unnamed_block          | unnamed_exit            |
              unnamed_loop_exited    | unnamed_for_loop        |
              unnamed_multiple_loop  | unnamed_simple_loop     |
              unnamed_while_loop     | untyped_for             |
              while_loop
Control occurrences of Ada statements

Rule: STYLE
Parameter(1): casing_attribute       | casing_identifier      |
              casing_keyword         | casing_pragma          |
              compound_statement     | default_in             |
              exposed_literal        | multiple_elements      |
              negative_condition     | no_closing_name        |
              numeric_literal        | parameter_order        |
              formal_parameter_order | positional_association |
              renamed_entity
For casing_*:
   Parameter (2): uppercase | lowercase | titlecase | original
                  (default = Original)
For exposed_literal:
   Parameter (2)  : integer | real | character | string
   Parameter (3..): <value>  | constant | number      | var_init |
                    type     | pragma   | repr_clause | index    |
                    exponent
                    (optional)
For multiple_elements:
   Parameter (2..): [flexible] clause | declaration | statement
                               (default = all)
For no_closing_name:
   Parameter (2): maximum number of lines allowed
For numeric_literal:
   Parameter (2): [not] <base>
   Parameter (3): <block_size>
For parameter_order:
   parameter (2..): list of in        | defaulted_in | access  |
                            in_out    | out          | type    |
                            procedure | function     | package
For positional_association:
   Parameter (2..): [not_operator] call            | discriminant     |
                                   pragma          | instantiation    |
                                   array_aggregate | record_aggregate
                                   (default = all, each value may be followed by allowed number of occurrences)
Control various Ada style issues

Rule: TERMINATING_TASKS
Control task termination.

Rule: TYPE_INITIAL_VALUES
Parameter(1): <pattern>
Control types without proper initialization constants

Rule: UNCHECKABLE
Parameter(s): false_positive | false_negative | missing_unit
              (optional, default = all)
Control occurrences of uncheckable constructs in other rules

Rule: UNITS
Parameter(s): unreferenced | unchecked
Control units not analyzed, or not referenced from the rest of the project

Rule: UNNECESSARY_USE_CLAUSE
Parameter(s): unused | qualified | operator | nested | movable
Control use clauses that can be removed, moved, or changed to use type.

Rule: UNSAFE_PAIRED_CALLS
Parameter(1): First subprogram
Parameter(2): Second subprogram
Parameter(3): (optional) type of lock parameter
Controls calls like P/V operations that are not safely paired

Rule: UNSAFE_UNCHECKED_CONVERSION
Parameter(s): none
Control unsafe usage of Unchecked_Conversion

Rule: USAGE
Parameter(s): variable | object    {, [not] <location> | initialized | read | written}
  or        : constant             {, [not] <location> | read}
  or        : type                 {, [not] <location> | used}
  or        : procedure | function {, [not] <location> | called}
  or        : exception            {, [not] <location> | raised | handled}
  or        : task                 {, [not] <location> | called | aborted}
  or        : protected            {, [not] <location> | called}
  or        : generic              {, [not] <location> | instantiated}
  or        : all                  [, [not] <location>]
location ::= from_visible | from_private | from_spec
Control usage of various entities
(possibly restricted to those that match the specified location and properties)

Rule: USE_CLAUSES
Parameter(1):  <Allowed package name> | local | global
               (optional)
Parameter(2..): <Allowed package name>
Control occurrences of use clauses that mention
any package but the ones passed as parameters (if any)

Rule: WITH_CLAUSES
Parameter(s): multiple_names | reduceable | inherited
Control "with" clauses that use multiple names, can be moved to a more reduced scope,
or are implicitely inherited from a parent unit

