Rule: ABNORMAL_FUNCTION_RETURN
Parameter(s): none
Control functions that can propagate Program_Error due to not executing a return statement

Rule: ALLOCATORS
Parameter(s): task | protected | <allocated type> (optional)
Control occurrences of allocators, either all of them,
or just those for tasks, protected types, or specific type(s)

Rule: CASE_STATEMENT
Parameter(1): min_others_range | max_values | min_paths
Parameter(2): for min_others_range: minimum number of values allowed for others
              for max_values      : maximum number of values allowed in the selector's subtype
              for min_paths       : minimum number of 'when' allowed in the case statement
Controls various sizes related to the case statement

Rule: CONTROL_CHARACTERS
Parameter: None
Controls source lines that contain the control characters allowed by the language

Rule: DECLARATIONS
Parameter (s): access_protected_type       | access_subprogram_type |
               access_task_type            | access_type            |
               aliased                     | array                  |
               array_type                  | child_unit             |
               constant                    | constrained_array_type |
               decimal_fixed_type          | defaulted_discriminant |
               defaulted_generic_parameter | defaulted_parameter    |
               derived_type                | discriminant           |
               enumeration_type            | entry                  |
               exception                   | extension              |
               fixed_type                  | float_type             |
               formal_function             | formal_in_out          |
               formal_package              | formal_procedure       |
               generic                     | handlers               |
               integer_type                | modular_type           |
               multiple_names              | named_number           |
               not_operator_renames        | null_extension         |
               null_ordinary_record_type   | null_tagged_type       |
               operator                    | ordinary_fixed_type    |
               ordinary_record_type        | package_statements     |
               protected                   | protected_entry        |
               protected_type              | record_type            |
               renames                     | separate               |
               signed_type                 | single_array           |
               single_protected            | single_task            |
               subtype                     | tagged_type            |
               task                        | task_entry             |
               task_type                   | type                   |
               unconstrained_array_type
Control occurrences of Ada declarations

Rule: DEFAULT_PARAMETER
Parameter 1: <Subprogram or generic name>
Parameter 2: <Formal parameter name>
Parameter 3: [not] used
Control subprogram calls or generic instantiations that use (or not)
the default value for a given parameter

Rule: DIRECTLY_ACCESSED_GLOBALS
Parameter(s): plain | accept | protected
              (optional)
Control global package variables accessed by other than dedicated subprograms

Rule: ENTITIES
Parameter(s): <Entity name>
Control occurrences of any Ada entity

Rule: ENTITY_INSIDE_EXCEPTION
Parameter(s): <Entity name>
Control occurrences of an entity inside an exception handler.

Rule: EXCEPTION_PROPAGATION
Parameter 1     : [<level>,] interface   | parameter | task |
                             declaration
                             (<level> is required for declaration)
Parameter 2 .. N: for interface: <convention name>
                  for parameter: <full name of parameters known to expect call-backs>
                  for task: nothing
                  for declaration: nothing
Control that certain kinds of subprograms, tasks, or declarations cannot propagate exceptions

Rule: GLOBAL_REFERENCES
Parameter(1):  all                 | multiple |
               multiple_non_atomic
Parameter(2..N):  <name> | task | protected
Control global (in a relative sense) variables referenced 
directly or indirectly from some specific constructs

Rule: HEADER_COMMENTS
Parameter: <Required number of comment lines>
Control that  each unit starts with (at least indicated number of comment lines

Rule: IF_FOR_CASE
Parameter(s): none
Control if statements that could be replaced by case statements

Rule: INSTANTIATIONS
Parameter 1     : <Generic name>
Parameter 2 .. N: <Entity name> (optional)
Control generic instantiations, either all of them
or those made with the given entities

Rule: LOCAL_HIDING
Parameter(s): none
Control occurrences of local identifiers that hide an outer identical name

Rule: LOCAL_INSTANTIATION
Parameter(s) (optional): <generic name>
Control instantiations that are done in a local scope.

Rule: MAX_BLANK_LINES
Parameter: <Max allowed consecutive blank lines>
Control that there is no more than the indicated number of consecutive blank lines

Rule: MAX_LINE_LENGTH
Parameter: <Max allowed length>
Control that no source line is longer than the indicated maximum

Rule: MAX_NESTING
Parameter 1: <maximum allowed nesting level>
Control scopes nested deeper than a given limit.

Rule: MAX_STATEMENT_NESTING
Parameter 1: if | case | loop | all
Parameter 2: nesting depth
Control max nesting of compound statements

Rule: MOVABLE_ACCEPT_STATEMENTS
Parameter(1): both | certain | possible
Parameter(2..N): <name>
Control (re)movable statements from `accept' bodies.
Movable statements might be moved to an outer scope.

Rule: NAMING_CONVENTION
Parameter 1:  all                      | type                    |
              discrete_type            | enumeration_type        |
              integer_type             | signed_integer_type     |
              modular_integer_type     | floating_point_type     |
              fixed_point_type         | binary_fixed_point_type |
              decimal_fixed_point_type | array_type              |
              record_type              | regular_record_type     |
              tagged_type              | class_type              |
              access_type              | access_to_regular_type  |
              access_to_tagged_type    | access_to_class_type    |
              access_to_sp_type        | access_to_task_type     |
              access_to_protected_type | private_type            |
              private_extension        | generic_formal_type     |
              variable                 | regular_variable        |
              field                    | discriminant            |
              record_field             | protected_field         |
              procedure_formal_out     | procedure_formal_in_out |
              generic_formal_in_out    | constant                |
              regular_constant         | named_number            |
              integer_number           | real_number             |
              enumeration              | sp_formal_in            |
              generic_formal_in        | loop_control            |
              occurrence_name          | entry_index             |
              label                    | stmt_name               |
              loop_name                | block_name              |
              subprogram               | procedure               |
              regular_procedure        | protected_procedure     |
              generic_formal_procedure | function                |
              regular_function         | protected_function      |
              generic_formal_function  | entry                   |
              task_entry               | protected_entry         |
              package                  | regular_package         |
              generic_formal_package   | task                    |
              task_type                | task_object             |
              protected                | protected_type          |
              protected_object         | exception               |
              generic                  | generic_package         |
              generic_sp               | generic_procedure       |
              generic_function
Parameter 2..N: [any|local|global] [case_sensitive|case_insensitive] [not] "<name pattern>"
Control the form of allowed (or forbidden) names in declarations

Rule: NON_STATIC_CONSTRAINTS
Parameter 1: index | discriminant
             (optional)
Control that index and discriminant constraints use only static expressions

Rule: NOT_ELABORATION_CALLS
Parameter(s): <subprogram name>
Control subprogram calls that happen elsewhere than as part
of the elaboration of a library package.

Rule: NO_SAFE_INITIALIZATION
Parameter(s):  out_parameter | variable
Control out parameters and local variables that are not initialized.
before the first compound statement

Rule: PARAMETER_ALIASING
Parameter 1: unlikely | possible | certain
             (optional, default=certain)
Control subprogram or entry calls where the same variable is given
for more than one [in] out parameter.
This rule can detect non-straightforward aliasing cases, see doc for details

Rule: POSITIONAL_PARAMETERS
Parameter(1): insufficient | maximum
Parameter(2): Allowed number of "insufficient" or "maximum" parameters
Parameter(3..N): Enumeration type names whose values are insufficient
Control calls where absence of named notation can lead to confusion

Rule: POTENTIALLY_BLOCKING_OPERATIONS
Parameter(s): None
Control calls to potentially blocking operations from protected operations

Rule: PRAGMAS
Parameter(s): all | nonstandard | <pragma names>
Control usage of specific pragmas

Rule: REAL_OPERATORS
Parameter(s): None
Control occurrences of = or /= operators with real types

Rule: REDUCEABLE_SCOPE
Parameter:  no_blocks
            (optional)
Control declarations that could be moved to an inner scope,
I.e. where all references are from a single nested scope

Rule: REPRESENTATION_CLAUSES
Parameter(s): <specifiable attribute> | at     | at_mod |
              enumeration             | record
              (optional)
Control occurrences of representation clauses

Rule: RETURN_TYPE
Parameter(s):  class_wide          | unconstrained_discriminated |
               unconstrained_array | protected                   |
               task
Control return types for functions.
Functions may return unconstrained types, class-wide types,protected types or task types, which can be inconvenient for certain systems.

Rule: SIDE_EFFECT_PARAMETERS
Parameter(s): <side effect function names>
Control subprogram calls or generic instantiations that call
functions with side effect and where the order of evaluation matters

Rule: SILENT_EXCEPTIONS
Parameter(s): <report procedure name> | raise
Control exception handlers that do not re-raise an exception 
nor call a report procedure

Rule: SIMPLIFIABLE_EXPRESSIONS
Parameter(s): range   | logical_true | logical_false | parentheses |
              logical
              (optional, default=all)
Control occurrence of various forms of expressions that could be made simpler:
  T'FIRST .. T'LAST that can be replaced by T'RANGE or T.
  <expression> = (/=) True/False
  Unnecessary parentheses

Rule: SPECIAL_COMMENTS
Parameter(s): Special comment pattern
Control comments that match the specified pattern

Rule: STATEMENTS
Parameter(s): abort                 | accept_return          |
              asynchronous_select   | case_others            |
              case_others_null      | conditional_entry_call |
              delay                 | delay_until            |
              entry_return          | exception_others       |
              exception_others_null | exit                   |
              exit_for_loop         | exit_while_loop        |
              function_return       | goto                   |
              loop_return           | multiple_exits         |
              no_else               | procedure_return       |
              raise                 | raise_standard         |
              requeue               | selective_accept       |
              terminate             | timed_entry_call       |
              unconditional_exit    | unnamed_exit           |
              unnamed_multiple_loop | untyped_for            |
              while_true
Control occurrences of Ada statements

Rule: STYLE
Parameter(1):  negative_condition | default_in             |
               no_closing_name    | positional_association |
               casing             | literal                |
               multiple_elements  | exposed_literal
Parameter (2):   For no_closing_name   : maximum number of lines for allowing no closing name
                 For named_association : call      | Instantiation | Aggregate
                 For casing            : Uppercase | Lowercase     | Titlecase | Original
                                       (default = Original)
                 For element_span      : none
                 For literal           : [not] <base>
                 For exposed_literal   : <value>
Parameter (3):   For literal           : <block_size>
                 For exposed_literal   : <value>
Parameter (4..): For exposed_literal   : <value>
Control various Ada style issues

Rule: TERMINATING_TASKS
Control task termination.

Rule: UNNECESSARY_USE_CLAUSE
Parameter(s): none
Control use clauses for packages, where no element of the package
is referenced in the scope of the use clause.

Rule: UNSAFE_PAIRED_CALLS
Parameter(1): First subprogram
Parameter(2): Second subprogram
Parameter(3): (optional) type of lock parameter
Controls calls like P/V operations that are not safely paired

Rule: USAGE
Parameter(s): variable | object {, [not] from_spec | initialized | read | written}
  or        : constant          {, [not] from_spec | read}
  or        : exception         {, [not] from_spec | raised | handled}
  or        : task              {, [not] from_spec | called | aborted}
  or        : protected         {, [not] from_spec | called}
  or        : all               [, [not] from_spec]
Control usage of entities declared in package specifications
(possibly restricted to those that match the specified properties)

Rule: USE_CLAUSES
Parameter(s): Allowed package names
Control occurrences of use clauses that mention
any package but the ones passed as parameters (if any)

Rule: WITH_CLAUSES
Parameter(s): reduceable | inherited
Control "with" clauses that use multiple names, can be moved to a more reduced scope,
or are implicitely inherited from a parent unit

